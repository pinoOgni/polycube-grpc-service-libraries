// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: polycube_grpc_commons.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_polycube_5fgrpc_5fcommons_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_polycube_5fgrpc_5fcommons_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_polycube_5fgrpc_5fcommons_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_polycube_5fgrpc_5fcommons_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_polycube_5fgrpc_5fcommons_2eproto;
namespace commons {
class Bool;
struct BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class CubeInfo;
struct CubeInfoDefaultTypeInternal;
extern CubeInfoDefaultTypeInternal _CubeInfo_default_instance_;
class CubeManagement;
struct CubeManagementDefaultTypeInternal;
extern CubeManagementDefaultTypeInternal _CubeManagement_default_instance_;
class Dataplane;
struct DataplaneDefaultTypeInternal;
extern DataplaneDefaultTypeInternal _Dataplane_default_instance_;
class DataplaneToServicedPacket;
struct DataplaneToServicedPacketDefaultTypeInternal;
extern DataplaneToServicedPacketDefaultTypeInternal _DataplaneToServicedPacket_default_instance_;
class DataplaneToServicedRequest;
struct DataplaneToServicedRequestDefaultTypeInternal;
extern DataplaneToServicedRequestDefaultTypeInternal _DataplaneToServicedRequest_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class Index;
struct IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class MapValue;
struct MapValueDefaultTypeInternal;
extern MapValueDefaultTypeInternal _MapValue_default_instance_;
class Port;
struct PortDefaultTypeInternal;
extern PortDefaultTypeInternal _Port_default_instance_;
class RemoveRequest;
struct RemoveRequestDefaultTypeInternal;
extern RemoveRequestDefaultTypeInternal _RemoveRequest_default_instance_;
class RestUserToServicedRequest;
struct RestUserToServicedRequestDefaultTypeInternal;
extern RestUserToServicedRequestDefaultTypeInternal _RestUserToServicedRequest_default_instance_;
class ServicedInfo;
struct ServicedInfoDefaultTypeInternal;
extern ServicedInfoDefaultTypeInternal _ServicedInfo_default_instance_;
class ServicedToDataplaneReply;
struct ServicedToDataplaneReplyDefaultTypeInternal;
extern ServicedToDataplaneReplyDefaultTypeInternal _ServicedToDataplaneReply_default_instance_;
class ServicedToDataplaneRequest;
struct ServicedToDataplaneRequestDefaultTypeInternal;
extern ServicedToDataplaneRequestDefaultTypeInternal _ServicedToDataplaneRequest_default_instance_;
class ServicedToRestUserReply;
struct ServicedToRestUserReplyDefaultTypeInternal;
extern ServicedToRestUserReplyDefaultTypeInternal _ServicedToRestUserReply_default_instance_;
class SetRequest;
struct SetRequestDefaultTypeInternal;
extern SetRequestDefaultTypeInternal _SetRequest_default_instance_;
class ToPolycubed;
struct ToPolycubedDefaultTypeInternal;
extern ToPolycubedDefaultTypeInternal _ToPolycubed_default_instance_;
class ToServiced;
struct ToServicedDefaultTypeInternal;
extern ToServicedDefaultTypeInternal _ToServiced_default_instance_;
}  // namespace commons
PROTOBUF_NAMESPACE_OPEN
template<> ::commons::Bool* Arena::CreateMaybeMessage<::commons::Bool>(Arena*);
template<> ::commons::CubeInfo* Arena::CreateMaybeMessage<::commons::CubeInfo>(Arena*);
template<> ::commons::CubeManagement* Arena::CreateMaybeMessage<::commons::CubeManagement>(Arena*);
template<> ::commons::Dataplane* Arena::CreateMaybeMessage<::commons::Dataplane>(Arena*);
template<> ::commons::DataplaneToServicedPacket* Arena::CreateMaybeMessage<::commons::DataplaneToServicedPacket>(Arena*);
template<> ::commons::DataplaneToServicedRequest* Arena::CreateMaybeMessage<::commons::DataplaneToServicedRequest>(Arena*);
template<> ::commons::Empty* Arena::CreateMaybeMessage<::commons::Empty>(Arena*);
template<> ::commons::GetRequest* Arena::CreateMaybeMessage<::commons::GetRequest>(Arena*);
template<> ::commons::Index* Arena::CreateMaybeMessage<::commons::Index>(Arena*);
template<> ::commons::MapValue* Arena::CreateMaybeMessage<::commons::MapValue>(Arena*);
template<> ::commons::Port* Arena::CreateMaybeMessage<::commons::Port>(Arena*);
template<> ::commons::RemoveRequest* Arena::CreateMaybeMessage<::commons::RemoveRequest>(Arena*);
template<> ::commons::RestUserToServicedRequest* Arena::CreateMaybeMessage<::commons::RestUserToServicedRequest>(Arena*);
template<> ::commons::ServicedInfo* Arena::CreateMaybeMessage<::commons::ServicedInfo>(Arena*);
template<> ::commons::ServicedToDataplaneReply* Arena::CreateMaybeMessage<::commons::ServicedToDataplaneReply>(Arena*);
template<> ::commons::ServicedToDataplaneRequest* Arena::CreateMaybeMessage<::commons::ServicedToDataplaneRequest>(Arena*);
template<> ::commons::ServicedToRestUserReply* Arena::CreateMaybeMessage<::commons::ServicedToRestUserReply>(Arena*);
template<> ::commons::SetRequest* Arena::CreateMaybeMessage<::commons::SetRequest>(Arena*);
template<> ::commons::ToPolycubed* Arena::CreateMaybeMessage<::commons::ToPolycubed>(Arena*);
template<> ::commons::ToServiced* Arena::CreateMaybeMessage<::commons::ToServiced>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace commons {

enum ServicedInfo_ServiceType : int {
  ServicedInfo_ServiceType_STANDARD = 0,
  ServicedInfo_ServiceType_TRANSPARENT = 1,
  ServicedInfo_ServiceType_ServicedInfo_ServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServicedInfo_ServiceType_ServicedInfo_ServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServicedInfo_ServiceType_IsValid(int value);
constexpr ServicedInfo_ServiceType ServicedInfo_ServiceType_ServiceType_MIN = ServicedInfo_ServiceType_STANDARD;
constexpr ServicedInfo_ServiceType ServicedInfo_ServiceType_ServiceType_MAX = ServicedInfo_ServiceType_TRANSPARENT;
constexpr int ServicedInfo_ServiceType_ServiceType_ARRAYSIZE = ServicedInfo_ServiceType_ServiceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServicedInfo_ServiceType_descriptor();
template<typename T>
inline const std::string& ServicedInfo_ServiceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServicedInfo_ServiceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServicedInfo_ServiceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServicedInfo_ServiceType_descriptor(), enum_t_value);
}
inline bool ServicedInfo_ServiceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServicedInfo_ServiceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServicedInfo_ServiceType>(
    ServicedInfo_ServiceType_descriptor(), name, value);
}
enum CubeInfo_ProgramType : int {
  CubeInfo_ProgramType_INGRESS = 0,
  CubeInfo_ProgramType_EGRESS = 1,
  CubeInfo_ProgramType_CubeInfo_ProgramType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CubeInfo_ProgramType_CubeInfo_ProgramType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CubeInfo_ProgramType_IsValid(int value);
constexpr CubeInfo_ProgramType CubeInfo_ProgramType_ProgramType_MIN = CubeInfo_ProgramType_INGRESS;
constexpr CubeInfo_ProgramType CubeInfo_ProgramType_ProgramType_MAX = CubeInfo_ProgramType_EGRESS;
constexpr int CubeInfo_ProgramType_ProgramType_ARRAYSIZE = CubeInfo_ProgramType_ProgramType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CubeInfo_ProgramType_descriptor();
template<typename T>
inline const std::string& CubeInfo_ProgramType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CubeInfo_ProgramType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CubeInfo_ProgramType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CubeInfo_ProgramType_descriptor(), enum_t_value);
}
inline bool CubeInfo_ProgramType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CubeInfo_ProgramType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CubeInfo_ProgramType>(
    CubeInfo_ProgramType_descriptor(), name, value);
}
enum CubeManagement_ServiceType : int {
  CubeManagement_ServiceType_STANDARD = 0,
  CubeManagement_ServiceType_TRANSPARENT = 1,
  CubeManagement_ServiceType_CubeManagement_ServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CubeManagement_ServiceType_CubeManagement_ServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CubeManagement_ServiceType_IsValid(int value);
constexpr CubeManagement_ServiceType CubeManagement_ServiceType_ServiceType_MIN = CubeManagement_ServiceType_STANDARD;
constexpr CubeManagement_ServiceType CubeManagement_ServiceType_ServiceType_MAX = CubeManagement_ServiceType_TRANSPARENT;
constexpr int CubeManagement_ServiceType_ServiceType_ARRAYSIZE = CubeManagement_ServiceType_ServiceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CubeManagement_ServiceType_descriptor();
template<typename T>
inline const std::string& CubeManagement_ServiceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CubeManagement_ServiceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CubeManagement_ServiceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CubeManagement_ServiceType_descriptor(), enum_t_value);
}
inline bool CubeManagement_ServiceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CubeManagement_ServiceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CubeManagement_ServiceType>(
    CubeManagement_ServiceType_descriptor(), name, value);
}
enum Port_PortStatus : int {
  Port_PortStatus_DOWN = 0,
  Port_PortStatus_UP = 1,
  Port_PortStatus_Port_PortStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Port_PortStatus_Port_PortStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Port_PortStatus_IsValid(int value);
constexpr Port_PortStatus Port_PortStatus_PortStatus_MIN = Port_PortStatus_DOWN;
constexpr Port_PortStatus Port_PortStatus_PortStatus_MAX = Port_PortStatus_UP;
constexpr int Port_PortStatus_PortStatus_ARRAYSIZE = Port_PortStatus_PortStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Port_PortStatus_descriptor();
template<typename T>
inline const std::string& Port_PortStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Port_PortStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Port_PortStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Port_PortStatus_descriptor(), enum_t_value);
}
inline bool Port_PortStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Port_PortStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Port_PortStatus>(
    Port_PortStatus_descriptor(), name, value);
}
enum Port_PortType : int {
  Port_PortType_TC = 0,
  Port_PortType_XDP = 1,
  Port_PortType_Port_PortType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Port_PortType_Port_PortType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Port_PortType_IsValid(int value);
constexpr Port_PortType Port_PortType_PortType_MIN = Port_PortType_TC;
constexpr Port_PortType Port_PortType_PortType_MAX = Port_PortType_XDP;
constexpr int Port_PortType_PortType_ARRAYSIZE = Port_PortType_PortType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Port_PortType_descriptor();
template<typename T>
inline const std::string& Port_PortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Port_PortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Port_PortType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Port_PortType_descriptor(), enum_t_value);
}
inline bool Port_PortType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Port_PortType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Port_PortType>(
    Port_PortType_descriptor(), name, value);
}
enum Dataplane_ProgramType : int {
  Dataplane_ProgramType_INGRESS = 0,
  Dataplane_ProgramType_EGRESS = 1,
  Dataplane_ProgramType_Dataplane_ProgramType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Dataplane_ProgramType_Dataplane_ProgramType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Dataplane_ProgramType_IsValid(int value);
constexpr Dataplane_ProgramType Dataplane_ProgramType_ProgramType_MIN = Dataplane_ProgramType_INGRESS;
constexpr Dataplane_ProgramType Dataplane_ProgramType_ProgramType_MAX = Dataplane_ProgramType_EGRESS;
constexpr int Dataplane_ProgramType_ProgramType_ARRAYSIZE = Dataplane_ProgramType_ProgramType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Dataplane_ProgramType_descriptor();
template<typename T>
inline const std::string& Dataplane_ProgramType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Dataplane_ProgramType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Dataplane_ProgramType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Dataplane_ProgramType_descriptor(), enum_t_value);
}
inline bool Dataplane_ProgramType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Dataplane_ProgramType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Dataplane_ProgramType>(
    Dataplane_ProgramType_descriptor(), name, value);
}
// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:commons.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:commons.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class Bool final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.Bool) */ {
 public:
  inline Bool() : Bool(nullptr) {}
  ~Bool() override;
  explicit constexpr Bool(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bool(const Bool& from);
  Bool(Bool&& from) noexcept
    : Bool() {
    *this = ::std::move(from);
  }

  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bool& operator=(Bool&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bool& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bool* internal_default_instance() {
    return reinterpret_cast<const Bool*>(
               &_Bool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Bool& a, Bool& b) {
    a.Swap(&b);
  }
  inline void Swap(Bool* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bool* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Bool>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bool& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bool& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bool* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.Bool";
  }
  protected:
  explicit Bool(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // bool status = 1;
  void clear_status();
  bool status() const;
  void set_status(bool value);
  private:
  bool _internal_status() const;
  void _internal_set_status(bool value);
  public:

  // @@protoc_insertion_point(class_scope:commons.Bool)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class ServicedInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.ServicedInfo) */ {
 public:
  inline ServicedInfo() : ServicedInfo(nullptr) {}
  ~ServicedInfo() override;
  explicit constexpr ServicedInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServicedInfo(const ServicedInfo& from);
  ServicedInfo(ServicedInfo&& from) noexcept
    : ServicedInfo() {
    *this = ::std::move(from);
  }

  inline ServicedInfo& operator=(const ServicedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServicedInfo& operator=(ServicedInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServicedInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServicedInfo* internal_default_instance() {
    return reinterpret_cast<const ServicedInfo*>(
               &_ServicedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ServicedInfo& a, ServicedInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServicedInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServicedInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServicedInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServicedInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServicedInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServicedInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServicedInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.ServicedInfo";
  }
  protected:
  explicit ServicedInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServicedInfo_ServiceType ServiceType;
  static constexpr ServiceType STANDARD =
    ServicedInfo_ServiceType_STANDARD;
  static constexpr ServiceType TRANSPARENT =
    ServicedInfo_ServiceType_TRANSPARENT;
  static inline bool ServiceType_IsValid(int value) {
    return ServicedInfo_ServiceType_IsValid(value);
  }
  static constexpr ServiceType ServiceType_MIN =
    ServicedInfo_ServiceType_ServiceType_MIN;
  static constexpr ServiceType ServiceType_MAX =
    ServicedInfo_ServiceType_ServiceType_MAX;
  static constexpr int ServiceType_ARRAYSIZE =
    ServicedInfo_ServiceType_ServiceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ServiceType_descriptor() {
    return ServicedInfo_ServiceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ServiceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ServiceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ServiceType_Name.");
    return ServicedInfo_ServiceType_Name(enum_t_value);
  }
  static inline bool ServiceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ServiceType* value) {
    return ServicedInfo_ServiceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServiceNameFieldNumber = 1,
    kCubeNameFieldNumber = 4,
    kPortNameFieldNumber = 5,
    kPeerNameFieldNumber = 6,
    kUuidFieldNumber = 2,
    kServiceTypeFieldNumber = 3,
  };
  // string service_name = 1;
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // optional string cube_name = 4;
  bool has_cube_name() const;
  private:
  bool _internal_has_cube_name() const;
  public:
  void clear_cube_name();
  const std::string& cube_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cube_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cube_name();
  PROTOBUF_NODISCARD std::string* release_cube_name();
  void set_allocated_cube_name(std::string* cube_name);
  private:
  const std::string& _internal_cube_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cube_name(const std::string& value);
  std::string* _internal_mutable_cube_name();
  public:

  // optional string port_name = 5;
  bool has_port_name() const;
  private:
  bool _internal_has_port_name() const;
  public:
  void clear_port_name();
  const std::string& port_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_port_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_port_name();
  PROTOBUF_NODISCARD std::string* release_port_name();
  void set_allocated_port_name(std::string* port_name);
  private:
  const std::string& _internal_port_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port_name(const std::string& value);
  std::string* _internal_mutable_port_name();
  public:

  // optional string peer_name = 6;
  bool has_peer_name() const;
  private:
  bool _internal_has_peer_name() const;
  public:
  void clear_peer_name();
  const std::string& peer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_name();
  PROTOBUF_NODISCARD std::string* release_peer_name();
  void set_allocated_peer_name(std::string* peer_name);
  private:
  const std::string& _internal_peer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_name(const std::string& value);
  std::string* _internal_mutable_peer_name();
  public:

  // int32 uuid = 2;
  void clear_uuid();
  int32_t uuid() const;
  void set_uuid(int32_t value);
  private:
  int32_t _internal_uuid() const;
  void _internal_set_uuid(int32_t value);
  public:

  // optional .commons.ServicedInfo.ServiceType service_type = 3;
  bool has_service_type() const;
  private:
  bool _internal_has_service_type() const;
  public:
  void clear_service_type();
  ::commons::ServicedInfo_ServiceType service_type() const;
  void set_service_type(::commons::ServicedInfo_ServiceType value);
  private:
  ::commons::ServicedInfo_ServiceType _internal_service_type() const;
  void _internal_set_service_type(::commons::ServicedInfo_ServiceType value);
  public:

  // @@protoc_insertion_point(class_scope:commons.ServicedInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cube_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_name_;
  int32_t uuid_;
  int service_type_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class ToServiced final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.ToServiced) */ {
 public:
  inline ToServiced() : ToServiced(nullptr) {}
  ~ToServiced() override;
  explicit constexpr ToServiced(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToServiced(const ToServiced& from);
  ToServiced(ToServiced&& from) noexcept
    : ToServiced() {
    *this = ::std::move(from);
  }

  inline ToServiced& operator=(const ToServiced& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToServiced& operator=(ToServiced&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToServiced& default_instance() {
    return *internal_default_instance();
  }
  enum ToServicedCase {
    kDataplaneToServicedRequest = 2,
    kRestUserToServiceRequest = 3,
    kDataplaneToServicedPacket = 4,
    TO_SERVICED_NOT_SET = 0,
  };

  static inline const ToServiced* internal_default_instance() {
    return reinterpret_cast<const ToServiced*>(
               &_ToServiced_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ToServiced& a, ToServiced& b) {
    a.Swap(&b);
  }
  inline void Swap(ToServiced* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToServiced* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToServiced* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToServiced>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToServiced& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ToServiced& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToServiced* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.ToServiced";
  }
  protected:
  explicit ToServiced(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicedInfoFieldNumber = 1,
    kDataplaneToServicedRequestFieldNumber = 2,
    kRestUserToServiceRequestFieldNumber = 3,
    kDataplaneToServicedPacketFieldNumber = 4,
  };
  // .commons.ServicedInfo serviced_info = 1;
  bool has_serviced_info() const;
  private:
  bool _internal_has_serviced_info() const;
  public:
  void clear_serviced_info();
  const ::commons::ServicedInfo& serviced_info() const;
  PROTOBUF_NODISCARD ::commons::ServicedInfo* release_serviced_info();
  ::commons::ServicedInfo* mutable_serviced_info();
  void set_allocated_serviced_info(::commons::ServicedInfo* serviced_info);
  private:
  const ::commons::ServicedInfo& _internal_serviced_info() const;
  ::commons::ServicedInfo* _internal_mutable_serviced_info();
  public:
  void unsafe_arena_set_allocated_serviced_info(
      ::commons::ServicedInfo* serviced_info);
  ::commons::ServicedInfo* unsafe_arena_release_serviced_info();

  // .commons.DataplaneToServicedRequest dataplane_to_serviced_request = 2;
  bool has_dataplane_to_serviced_request() const;
  private:
  bool _internal_has_dataplane_to_serviced_request() const;
  public:
  void clear_dataplane_to_serviced_request();
  const ::commons::DataplaneToServicedRequest& dataplane_to_serviced_request() const;
  PROTOBUF_NODISCARD ::commons::DataplaneToServicedRequest* release_dataplane_to_serviced_request();
  ::commons::DataplaneToServicedRequest* mutable_dataplane_to_serviced_request();
  void set_allocated_dataplane_to_serviced_request(::commons::DataplaneToServicedRequest* dataplane_to_serviced_request);
  private:
  const ::commons::DataplaneToServicedRequest& _internal_dataplane_to_serviced_request() const;
  ::commons::DataplaneToServicedRequest* _internal_mutable_dataplane_to_serviced_request();
  public:
  void unsafe_arena_set_allocated_dataplane_to_serviced_request(
      ::commons::DataplaneToServicedRequest* dataplane_to_serviced_request);
  ::commons::DataplaneToServicedRequest* unsafe_arena_release_dataplane_to_serviced_request();

  // .commons.RestUserToServicedRequest rest_user_to_service_request = 3;
  bool has_rest_user_to_service_request() const;
  private:
  bool _internal_has_rest_user_to_service_request() const;
  public:
  void clear_rest_user_to_service_request();
  const ::commons::RestUserToServicedRequest& rest_user_to_service_request() const;
  PROTOBUF_NODISCARD ::commons::RestUserToServicedRequest* release_rest_user_to_service_request();
  ::commons::RestUserToServicedRequest* mutable_rest_user_to_service_request();
  void set_allocated_rest_user_to_service_request(::commons::RestUserToServicedRequest* rest_user_to_service_request);
  private:
  const ::commons::RestUserToServicedRequest& _internal_rest_user_to_service_request() const;
  ::commons::RestUserToServicedRequest* _internal_mutable_rest_user_to_service_request();
  public:
  void unsafe_arena_set_allocated_rest_user_to_service_request(
      ::commons::RestUserToServicedRequest* rest_user_to_service_request);
  ::commons::RestUserToServicedRequest* unsafe_arena_release_rest_user_to_service_request();

  // .commons.DataplaneToServicedPacket dataplane_to_serviced_packet = 4;
  bool has_dataplane_to_serviced_packet() const;
  private:
  bool _internal_has_dataplane_to_serviced_packet() const;
  public:
  void clear_dataplane_to_serviced_packet();
  const ::commons::DataplaneToServicedPacket& dataplane_to_serviced_packet() const;
  PROTOBUF_NODISCARD ::commons::DataplaneToServicedPacket* release_dataplane_to_serviced_packet();
  ::commons::DataplaneToServicedPacket* mutable_dataplane_to_serviced_packet();
  void set_allocated_dataplane_to_serviced_packet(::commons::DataplaneToServicedPacket* dataplane_to_serviced_packet);
  private:
  const ::commons::DataplaneToServicedPacket& _internal_dataplane_to_serviced_packet() const;
  ::commons::DataplaneToServicedPacket* _internal_mutable_dataplane_to_serviced_packet();
  public:
  void unsafe_arena_set_allocated_dataplane_to_serviced_packet(
      ::commons::DataplaneToServicedPacket* dataplane_to_serviced_packet);
  ::commons::DataplaneToServicedPacket* unsafe_arena_release_dataplane_to_serviced_packet();

  void clear_to_serviced();
  ToServicedCase to_serviced_case() const;
  // @@protoc_insertion_point(class_scope:commons.ToServiced)
 private:
  class _Internal;
  void set_has_dataplane_to_serviced_request();
  void set_has_rest_user_to_service_request();
  void set_has_dataplane_to_serviced_packet();

  inline bool has_to_serviced() const;
  inline void clear_has_to_serviced();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commons::ServicedInfo* serviced_info_;
  union ToServicedUnion {
    constexpr ToServicedUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::commons::DataplaneToServicedRequest* dataplane_to_serviced_request_;
    ::commons::RestUserToServicedRequest* rest_user_to_service_request_;
    ::commons::DataplaneToServicedPacket* dataplane_to_serviced_packet_;
  } to_serviced_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class RestUserToServicedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.RestUserToServicedRequest) */ {
 public:
  inline RestUserToServicedRequest() : RestUserToServicedRequest(nullptr) {}
  ~RestUserToServicedRequest() override;
  explicit constexpr RestUserToServicedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestUserToServicedRequest(const RestUserToServicedRequest& from);
  RestUserToServicedRequest(RestUserToServicedRequest&& from) noexcept
    : RestUserToServicedRequest() {
    *this = ::std::move(from);
  }

  inline RestUserToServicedRequest& operator=(const RestUserToServicedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestUserToServicedRequest& operator=(RestUserToServicedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestUserToServicedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestUserToServicedRequest* internal_default_instance() {
    return reinterpret_cast<const RestUserToServicedRequest*>(
               &_RestUserToServicedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RestUserToServicedRequest& a, RestUserToServicedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RestUserToServicedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestUserToServicedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestUserToServicedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestUserToServicedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestUserToServicedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RestUserToServicedRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestUserToServicedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.RestUserToServicedRequest";
  }
  protected:
  explicit RestUserToServicedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHttpVerbFieldNumber = 1,
    kUrlFieldNumber = 2,
    kRequestBodyFieldNumber = 3,
  };
  // string http_verb = 1;
  void clear_http_verb();
  const std::string& http_verb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_http_verb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_http_verb();
  PROTOBUF_NODISCARD std::string* release_http_verb();
  void set_allocated_http_verb(std::string* http_verb);
  private:
  const std::string& _internal_http_verb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_http_verb(const std::string& value);
  std::string* _internal_mutable_http_verb();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string request_body = 3;
  bool has_request_body() const;
  private:
  bool _internal_has_request_body() const;
  public:
  void clear_request_body();
  const std::string& request_body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_body();
  PROTOBUF_NODISCARD std::string* release_request_body();
  void set_allocated_request_body(std::string* request_body);
  private:
  const std::string& _internal_request_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_body(const std::string& value);
  std::string* _internal_mutable_request_body();
  public:

  // @@protoc_insertion_point(class_scope:commons.RestUserToServicedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr http_verb_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_body_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class DataplaneToServicedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.DataplaneToServicedRequest) */ {
 public:
  inline DataplaneToServicedRequest() : DataplaneToServicedRequest(nullptr) {}
  ~DataplaneToServicedRequest() override;
  explicit constexpr DataplaneToServicedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataplaneToServicedRequest(const DataplaneToServicedRequest& from);
  DataplaneToServicedRequest(DataplaneToServicedRequest&& from) noexcept
    : DataplaneToServicedRequest() {
    *this = ::std::move(from);
  }

  inline DataplaneToServicedRequest& operator=(const DataplaneToServicedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataplaneToServicedRequest& operator=(DataplaneToServicedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataplaneToServicedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataplaneToServicedRequest* internal_default_instance() {
    return reinterpret_cast<const DataplaneToServicedRequest*>(
               &_DataplaneToServicedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataplaneToServicedRequest& a, DataplaneToServicedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataplaneToServicedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataplaneToServicedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataplaneToServicedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataplaneToServicedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataplaneToServicedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataplaneToServicedRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataplaneToServicedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.DataplaneToServicedRequest";
  }
  protected:
  explicit DataplaneToServicedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kControlplaneMethodFieldNumber = 1,
  };
  // repeated bytes parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  const std::string& parameters(int index) const;
  std::string* mutable_parameters(int index);
  void set_parameters(int index, const std::string& value);
  void set_parameters(int index, std::string&& value);
  void set_parameters(int index, const char* value);
  void set_parameters(int index, const void* value, size_t size);
  std::string* add_parameters();
  void add_parameters(const std::string& value);
  void add_parameters(std::string&& value);
  void add_parameters(const char* value);
  void add_parameters(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& parameters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_parameters();
  private:
  const std::string& _internal_parameters(int index) const;
  std::string* _internal_add_parameters();
  public:

  // string controlplane_method = 1;
  void clear_controlplane_method();
  const std::string& controlplane_method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controlplane_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controlplane_method();
  PROTOBUF_NODISCARD std::string* release_controlplane_method();
  void set_allocated_controlplane_method(std::string* controlplane_method);
  private:
  const std::string& _internal_controlplane_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controlplane_method(const std::string& value);
  std::string* _internal_mutable_controlplane_method();
  public:

  // @@protoc_insertion_point(class_scope:commons.DataplaneToServicedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controlplane_method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class DataplaneToServicedPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.DataplaneToServicedPacket) */ {
 public:
  inline DataplaneToServicedPacket() : DataplaneToServicedPacket(nullptr) {}
  ~DataplaneToServicedPacket() override;
  explicit constexpr DataplaneToServicedPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataplaneToServicedPacket(const DataplaneToServicedPacket& from);
  DataplaneToServicedPacket(DataplaneToServicedPacket&& from) noexcept
    : DataplaneToServicedPacket() {
    *this = ::std::move(from);
  }

  inline DataplaneToServicedPacket& operator=(const DataplaneToServicedPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataplaneToServicedPacket& operator=(DataplaneToServicedPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataplaneToServicedPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataplaneToServicedPacket* internal_default_instance() {
    return reinterpret_cast<const DataplaneToServicedPacket*>(
               &_DataplaneToServicedPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataplaneToServicedPacket& a, DataplaneToServicedPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(DataplaneToServicedPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataplaneToServicedPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataplaneToServicedPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataplaneToServicedPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataplaneToServicedPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataplaneToServicedPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataplaneToServicedPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.DataplaneToServicedPacket";
  }
  protected:
  explicit DataplaneToServicedPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 6,
    kPacketFieldNumber = 7,
    kCubeIdFieldNumber = 1,
    kPortIdFieldNumber = 2,
    kPacketLenFieldNumber = 3,
    kTrafficClassFieldNumber = 4,
    kReasonFieldNumber = 5,
  };
  // repeated uint32 metadata = 6;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  uint32_t _internal_metadata(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_metadata() const;
  void _internal_add_metadata(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_metadata();
  public:
  uint32_t metadata(int index) const;
  void set_metadata(int index, uint32_t value);
  void add_metadata(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_metadata();

  // repeated uint32 packet = 7;
  int packet_size() const;
  private:
  int _internal_packet_size() const;
  public:
  void clear_packet();
  private:
  uint32_t _internal_packet(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_packet() const;
  void _internal_add_packet(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_packet();
  public:
  uint32_t packet(int index) const;
  void set_packet(int index, uint32_t value);
  void add_packet(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      packet() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_packet();

  // uint32 cube_id = 1;
  void clear_cube_id();
  uint32_t cube_id() const;
  void set_cube_id(uint32_t value);
  private:
  uint32_t _internal_cube_id() const;
  void _internal_set_cube_id(uint32_t value);
  public:

  // uint32 port_id = 2;
  void clear_port_id();
  uint32_t port_id() const;
  void set_port_id(uint32_t value);
  private:
  uint32_t _internal_port_id() const;
  void _internal_set_port_id(uint32_t value);
  public:

  // uint32 packet_len = 3;
  void clear_packet_len();
  uint32_t packet_len() const;
  void set_packet_len(uint32_t value);
  private:
  uint32_t _internal_packet_len() const;
  void _internal_set_packet_len(uint32_t value);
  public:

  // uint32 traffic_class = 4;
  void clear_traffic_class();
  uint32_t traffic_class() const;
  void set_traffic_class(uint32_t value);
  private:
  uint32_t _internal_traffic_class() const;
  void _internal_set_traffic_class(uint32_t value);
  public:

  // uint32 reason = 5;
  void clear_reason();
  uint32_t reason() const;
  void set_reason(uint32_t value);
  private:
  uint32_t _internal_reason() const;
  void _internal_set_reason(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:commons.DataplaneToServicedPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > metadata_;
  mutable std::atomic<int> _metadata_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > packet_;
  mutable std::atomic<int> _packet_cached_byte_size_;
  uint32_t cube_id_;
  uint32_t port_id_;
  uint32_t packet_len_;
  uint32_t traffic_class_;
  uint32_t reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class ToPolycubed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.ToPolycubed) */ {
 public:
  inline ToPolycubed() : ToPolycubed(nullptr) {}
  ~ToPolycubed() override;
  explicit constexpr ToPolycubed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToPolycubed(const ToPolycubed& from);
  ToPolycubed(ToPolycubed&& from) noexcept
    : ToPolycubed() {
    *this = ::std::move(from);
  }

  inline ToPolycubed& operator=(const ToPolycubed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToPolycubed& operator=(ToPolycubed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToPolycubed& default_instance() {
    return *internal_default_instance();
  }
  enum ToPolycubedCase {
    kSubscribe = 2,
    kServicedToDataplaneReply = 3,
    kServicedToRestUserReply = 4,
    TO_POLYCUBED_NOT_SET = 0,
  };

  static inline const ToPolycubed* internal_default_instance() {
    return reinterpret_cast<const ToPolycubed*>(
               &_ToPolycubed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ToPolycubed& a, ToPolycubed& b) {
    a.Swap(&b);
  }
  inline void Swap(ToPolycubed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToPolycubed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToPolycubed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToPolycubed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToPolycubed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ToPolycubed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToPolycubed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.ToPolycubed";
  }
  protected:
  explicit ToPolycubed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicedInfoFieldNumber = 1,
    kSubscribeFieldNumber = 2,
    kServicedToDataplaneReplyFieldNumber = 3,
    kServicedToRestUserReplyFieldNumber = 4,
  };
  // .commons.ServicedInfo serviced_info = 1;
  bool has_serviced_info() const;
  private:
  bool _internal_has_serviced_info() const;
  public:
  void clear_serviced_info();
  const ::commons::ServicedInfo& serviced_info() const;
  PROTOBUF_NODISCARD ::commons::ServicedInfo* release_serviced_info();
  ::commons::ServicedInfo* mutable_serviced_info();
  void set_allocated_serviced_info(::commons::ServicedInfo* serviced_info);
  private:
  const ::commons::ServicedInfo& _internal_serviced_info() const;
  ::commons::ServicedInfo* _internal_mutable_serviced_info();
  public:
  void unsafe_arena_set_allocated_serviced_info(
      ::commons::ServicedInfo* serviced_info);
  ::commons::ServicedInfo* unsafe_arena_release_serviced_info();

  // bool subscribe = 2;
  bool has_subscribe() const;
  private:
  bool _internal_has_subscribe() const;
  public:
  void clear_subscribe();
  bool subscribe() const;
  void set_subscribe(bool value);
  private:
  bool _internal_subscribe() const;
  void _internal_set_subscribe(bool value);
  public:

  // .commons.ServicedToDataplaneReply serviced_to_dataplane_reply = 3;
  bool has_serviced_to_dataplane_reply() const;
  private:
  bool _internal_has_serviced_to_dataplane_reply() const;
  public:
  void clear_serviced_to_dataplane_reply();
  const ::commons::ServicedToDataplaneReply& serviced_to_dataplane_reply() const;
  PROTOBUF_NODISCARD ::commons::ServicedToDataplaneReply* release_serviced_to_dataplane_reply();
  ::commons::ServicedToDataplaneReply* mutable_serviced_to_dataplane_reply();
  void set_allocated_serviced_to_dataplane_reply(::commons::ServicedToDataplaneReply* serviced_to_dataplane_reply);
  private:
  const ::commons::ServicedToDataplaneReply& _internal_serviced_to_dataplane_reply() const;
  ::commons::ServicedToDataplaneReply* _internal_mutable_serviced_to_dataplane_reply();
  public:
  void unsafe_arena_set_allocated_serviced_to_dataplane_reply(
      ::commons::ServicedToDataplaneReply* serviced_to_dataplane_reply);
  ::commons::ServicedToDataplaneReply* unsafe_arena_release_serviced_to_dataplane_reply();

  // .commons.ServicedToRestUserReply serviced_to_rest_user_reply = 4;
  bool has_serviced_to_rest_user_reply() const;
  private:
  bool _internal_has_serviced_to_rest_user_reply() const;
  public:
  void clear_serviced_to_rest_user_reply();
  const ::commons::ServicedToRestUserReply& serviced_to_rest_user_reply() const;
  PROTOBUF_NODISCARD ::commons::ServicedToRestUserReply* release_serviced_to_rest_user_reply();
  ::commons::ServicedToRestUserReply* mutable_serviced_to_rest_user_reply();
  void set_allocated_serviced_to_rest_user_reply(::commons::ServicedToRestUserReply* serviced_to_rest_user_reply);
  private:
  const ::commons::ServicedToRestUserReply& _internal_serviced_to_rest_user_reply() const;
  ::commons::ServicedToRestUserReply* _internal_mutable_serviced_to_rest_user_reply();
  public:
  void unsafe_arena_set_allocated_serviced_to_rest_user_reply(
      ::commons::ServicedToRestUserReply* serviced_to_rest_user_reply);
  ::commons::ServicedToRestUserReply* unsafe_arena_release_serviced_to_rest_user_reply();

  void clear_to_polycubed();
  ToPolycubedCase to_polycubed_case() const;
  // @@protoc_insertion_point(class_scope:commons.ToPolycubed)
 private:
  class _Internal;
  void set_has_subscribe();
  void set_has_serviced_to_dataplane_reply();
  void set_has_serviced_to_rest_user_reply();

  inline bool has_to_polycubed() const;
  inline void clear_has_to_polycubed();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commons::ServicedInfo* serviced_info_;
  union ToPolycubedUnion {
    constexpr ToPolycubedUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool subscribe_;
    ::commons::ServicedToDataplaneReply* serviced_to_dataplane_reply_;
    ::commons::ServicedToRestUserReply* serviced_to_rest_user_reply_;
  } to_polycubed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class ServicedToDataplaneReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.ServicedToDataplaneReply) */ {
 public:
  inline ServicedToDataplaneReply() : ServicedToDataplaneReply(nullptr) {}
  ~ServicedToDataplaneReply() override;
  explicit constexpr ServicedToDataplaneReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServicedToDataplaneReply(const ServicedToDataplaneReply& from);
  ServicedToDataplaneReply(ServicedToDataplaneReply&& from) noexcept
    : ServicedToDataplaneReply() {
    *this = ::std::move(from);
  }

  inline ServicedToDataplaneReply& operator=(const ServicedToDataplaneReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServicedToDataplaneReply& operator=(ServicedToDataplaneReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServicedToDataplaneReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServicedToDataplaneReply* internal_default_instance() {
    return reinterpret_cast<const ServicedToDataplaneReply*>(
               &_ServicedToDataplaneReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ServicedToDataplaneReply& a, ServicedToDataplaneReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ServicedToDataplaneReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServicedToDataplaneReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServicedToDataplaneReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServicedToDataplaneReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServicedToDataplaneReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServicedToDataplaneReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServicedToDataplaneReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.ServicedToDataplaneReply";
  }
  protected:
  explicit ServicedToDataplaneReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:commons.ServicedToDataplaneReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool success_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class ServicedToRestUserReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.ServicedToRestUserReply) */ {
 public:
  inline ServicedToRestUserReply() : ServicedToRestUserReply(nullptr) {}
  ~ServicedToRestUserReply() override;
  explicit constexpr ServicedToRestUserReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServicedToRestUserReply(const ServicedToRestUserReply& from);
  ServicedToRestUserReply(ServicedToRestUserReply&& from) noexcept
    : ServicedToRestUserReply() {
    *this = ::std::move(from);
  }

  inline ServicedToRestUserReply& operator=(const ServicedToRestUserReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServicedToRestUserReply& operator=(ServicedToRestUserReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServicedToRestUserReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServicedToRestUserReply* internal_default_instance() {
    return reinterpret_cast<const ServicedToRestUserReply*>(
               &_ServicedToRestUserReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ServicedToRestUserReply& a, ServicedToRestUserReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ServicedToRestUserReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServicedToRestUserReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServicedToRestUserReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServicedToRestUserReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServicedToRestUserReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServicedToRestUserReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServicedToRestUserReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.ServicedToRestUserReply";
  }
  protected:
  explicit ServicedToRestUserReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:commons.ServicedToRestUserReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool success_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class ServicedToDataplaneRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.ServicedToDataplaneRequest) */ {
 public:
  inline ServicedToDataplaneRequest() : ServicedToDataplaneRequest(nullptr) {}
  ~ServicedToDataplaneRequest() override;
  explicit constexpr ServicedToDataplaneRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServicedToDataplaneRequest(const ServicedToDataplaneRequest& from);
  ServicedToDataplaneRequest(ServicedToDataplaneRequest&& from) noexcept
    : ServicedToDataplaneRequest() {
    *this = ::std::move(from);
  }

  inline ServicedToDataplaneRequest& operator=(const ServicedToDataplaneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServicedToDataplaneRequest& operator=(ServicedToDataplaneRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServicedToDataplaneRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kSetRequest = 3,
    kGetRequest = 4,
    kRemoveRequest = 5,
    kPort = 6,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const ServicedToDataplaneRequest* internal_default_instance() {
    return reinterpret_cast<const ServicedToDataplaneRequest*>(
               &_ServicedToDataplaneRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ServicedToDataplaneRequest& a, ServicedToDataplaneRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServicedToDataplaneRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServicedToDataplaneRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServicedToDataplaneRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServicedToDataplaneRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServicedToDataplaneRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServicedToDataplaneRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServicedToDataplaneRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.ServicedToDataplaneRequest";
  }
  protected:
  explicit ServicedToDataplaneRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicedInfoFieldNumber = 1,
    kCubeInfoFieldNumber = 2,
    kSetRequestFieldNumber = 3,
    kGetRequestFieldNumber = 4,
    kRemoveRequestFieldNumber = 5,
    kPortFieldNumber = 6,
  };
  // .commons.ServicedInfo serviced_info = 1;
  bool has_serviced_info() const;
  private:
  bool _internal_has_serviced_info() const;
  public:
  void clear_serviced_info();
  const ::commons::ServicedInfo& serviced_info() const;
  PROTOBUF_NODISCARD ::commons::ServicedInfo* release_serviced_info();
  ::commons::ServicedInfo* mutable_serviced_info();
  void set_allocated_serviced_info(::commons::ServicedInfo* serviced_info);
  private:
  const ::commons::ServicedInfo& _internal_serviced_info() const;
  ::commons::ServicedInfo* _internal_mutable_serviced_info();
  public:
  void unsafe_arena_set_allocated_serviced_info(
      ::commons::ServicedInfo* serviced_info);
  ::commons::ServicedInfo* unsafe_arena_release_serviced_info();

  // .commons.CubeInfo cube_info = 2;
  bool has_cube_info() const;
  private:
  bool _internal_has_cube_info() const;
  public:
  void clear_cube_info();
  const ::commons::CubeInfo& cube_info() const;
  PROTOBUF_NODISCARD ::commons::CubeInfo* release_cube_info();
  ::commons::CubeInfo* mutable_cube_info();
  void set_allocated_cube_info(::commons::CubeInfo* cube_info);
  private:
  const ::commons::CubeInfo& _internal_cube_info() const;
  ::commons::CubeInfo* _internal_mutable_cube_info();
  public:
  void unsafe_arena_set_allocated_cube_info(
      ::commons::CubeInfo* cube_info);
  ::commons::CubeInfo* unsafe_arena_release_cube_info();

  // .commons.SetRequest set_request = 3;
  bool has_set_request() const;
  private:
  bool _internal_has_set_request() const;
  public:
  void clear_set_request();
  const ::commons::SetRequest& set_request() const;
  PROTOBUF_NODISCARD ::commons::SetRequest* release_set_request();
  ::commons::SetRequest* mutable_set_request();
  void set_allocated_set_request(::commons::SetRequest* set_request);
  private:
  const ::commons::SetRequest& _internal_set_request() const;
  ::commons::SetRequest* _internal_mutable_set_request();
  public:
  void unsafe_arena_set_allocated_set_request(
      ::commons::SetRequest* set_request);
  ::commons::SetRequest* unsafe_arena_release_set_request();

  // .commons.GetRequest get_request = 4;
  bool has_get_request() const;
  private:
  bool _internal_has_get_request() const;
  public:
  void clear_get_request();
  const ::commons::GetRequest& get_request() const;
  PROTOBUF_NODISCARD ::commons::GetRequest* release_get_request();
  ::commons::GetRequest* mutable_get_request();
  void set_allocated_get_request(::commons::GetRequest* get_request);
  private:
  const ::commons::GetRequest& _internal_get_request() const;
  ::commons::GetRequest* _internal_mutable_get_request();
  public:
  void unsafe_arena_set_allocated_get_request(
      ::commons::GetRequest* get_request);
  ::commons::GetRequest* unsafe_arena_release_get_request();

  // .commons.RemoveRequest remove_request = 5;
  bool has_remove_request() const;
  private:
  bool _internal_has_remove_request() const;
  public:
  void clear_remove_request();
  const ::commons::RemoveRequest& remove_request() const;
  PROTOBUF_NODISCARD ::commons::RemoveRequest* release_remove_request();
  ::commons::RemoveRequest* mutable_remove_request();
  void set_allocated_remove_request(::commons::RemoveRequest* remove_request);
  private:
  const ::commons::RemoveRequest& _internal_remove_request() const;
  ::commons::RemoveRequest* _internal_mutable_remove_request();
  public:
  void unsafe_arena_set_allocated_remove_request(
      ::commons::RemoveRequest* remove_request);
  ::commons::RemoveRequest* unsafe_arena_release_remove_request();

  // .commons.Port port = 6;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  const ::commons::Port& port() const;
  PROTOBUF_NODISCARD ::commons::Port* release_port();
  ::commons::Port* mutable_port();
  void set_allocated_port(::commons::Port* port);
  private:
  const ::commons::Port& _internal_port() const;
  ::commons::Port* _internal_mutable_port();
  public:
  void unsafe_arena_set_allocated_port(
      ::commons::Port* port);
  ::commons::Port* unsafe_arena_release_port();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:commons.ServicedToDataplaneRequest)
 private:
  class _Internal;
  void set_has_set_request();
  void set_has_get_request();
  void set_has_remove_request();
  void set_has_port();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::commons::ServicedInfo* serviced_info_;
  ::commons::CubeInfo* cube_info_;
  union RequestTypeUnion {
    constexpr RequestTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::commons::SetRequest* set_request_;
    ::commons::GetRequest* get_request_;
    ::commons::RemoveRequest* remove_request_;
    ::commons::Port* port_;
  } request_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class CubeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.CubeInfo) */ {
 public:
  inline CubeInfo() : CubeInfo(nullptr) {}
  ~CubeInfo() override;
  explicit constexpr CubeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CubeInfo(const CubeInfo& from);
  CubeInfo(CubeInfo&& from) noexcept
    : CubeInfo() {
    *this = ::std::move(from);
  }

  inline CubeInfo& operator=(const CubeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CubeInfo& operator=(CubeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CubeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CubeInfo* internal_default_instance() {
    return reinterpret_cast<const CubeInfo*>(
               &_CubeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CubeInfo& a, CubeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CubeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CubeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CubeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CubeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CubeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CubeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CubeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.CubeInfo";
  }
  protected:
  explicit CubeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CubeInfo_ProgramType ProgramType;
  static constexpr ProgramType INGRESS =
    CubeInfo_ProgramType_INGRESS;
  static constexpr ProgramType EGRESS =
    CubeInfo_ProgramType_EGRESS;
  static inline bool ProgramType_IsValid(int value) {
    return CubeInfo_ProgramType_IsValid(value);
  }
  static constexpr ProgramType ProgramType_MIN =
    CubeInfo_ProgramType_ProgramType_MIN;
  static constexpr ProgramType ProgramType_MAX =
    CubeInfo_ProgramType_ProgramType_MAX;
  static constexpr int ProgramType_ARRAYSIZE =
    CubeInfo_ProgramType_ProgramType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProgramType_descriptor() {
    return CubeInfo_ProgramType_descriptor();
  }
  template<typename T>
  static inline const std::string& ProgramType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProgramType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProgramType_Name.");
    return CubeInfo_ProgramType_Name(enum_t_value);
  }
  static inline bool ProgramType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProgramType* value) {
    return CubeInfo_ProgramType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCubeNameFieldNumber = 1,
    kMapNameFieldNumber = 2,
    kIndexFieldNumber = 3,
    kProgramTypeFieldNumber = 4,
  };
  // string cube_name = 1;
  void clear_cube_name();
  const std::string& cube_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cube_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cube_name();
  PROTOBUF_NODISCARD std::string* release_cube_name();
  void set_allocated_cube_name(std::string* cube_name);
  private:
  const std::string& _internal_cube_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cube_name(const std::string& value);
  std::string* _internal_mutable_cube_name();
  public:

  // string map_name = 2;
  void clear_map_name();
  const std::string& map_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_name();
  PROTOBUF_NODISCARD std::string* release_map_name();
  void set_allocated_map_name(std::string* map_name);
  private:
  const std::string& _internal_map_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_name(const std::string& value);
  std::string* _internal_mutable_map_name();
  public:

  // int32 index = 3;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // .commons.CubeInfo.ProgramType program_type = 4;
  void clear_program_type();
  ::commons::CubeInfo_ProgramType program_type() const;
  void set_program_type(::commons::CubeInfo_ProgramType value);
  private:
  ::commons::CubeInfo_ProgramType _internal_program_type() const;
  void _internal_set_program_type(::commons::CubeInfo_ProgramType value);
  public:

  // @@protoc_insertion_point(class_scope:commons.CubeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cube_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_name_;
  int32_t index_;
  int program_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class CubeManagement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.CubeManagement) */ {
 public:
  inline CubeManagement() : CubeManagement(nullptr) {}
  ~CubeManagement() override;
  explicit constexpr CubeManagement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CubeManagement(const CubeManagement& from);
  CubeManagement(CubeManagement&& from) noexcept
    : CubeManagement() {
    *this = ::std::move(from);
  }

  inline CubeManagement& operator=(const CubeManagement& from) {
    CopyFrom(from);
    return *this;
  }
  inline CubeManagement& operator=(CubeManagement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CubeManagement& default_instance() {
    return *internal_default_instance();
  }
  static inline const CubeManagement* internal_default_instance() {
    return reinterpret_cast<const CubeManagement*>(
               &_CubeManagement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CubeManagement& a, CubeManagement& b) {
    a.Swap(&b);
  }
  inline void Swap(CubeManagement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CubeManagement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CubeManagement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CubeManagement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CubeManagement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CubeManagement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CubeManagement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.CubeManagement";
  }
  protected:
  explicit CubeManagement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CubeManagement_ServiceType ServiceType;
  static constexpr ServiceType STANDARD =
    CubeManagement_ServiceType_STANDARD;
  static constexpr ServiceType TRANSPARENT =
    CubeManagement_ServiceType_TRANSPARENT;
  static inline bool ServiceType_IsValid(int value) {
    return CubeManagement_ServiceType_IsValid(value);
  }
  static constexpr ServiceType ServiceType_MIN =
    CubeManagement_ServiceType_ServiceType_MIN;
  static constexpr ServiceType ServiceType_MAX =
    CubeManagement_ServiceType_ServiceType_MAX;
  static constexpr int ServiceType_ARRAYSIZE =
    CubeManagement_ServiceType_ServiceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ServiceType_descriptor() {
    return CubeManagement_ServiceType_descriptor();
  }
  template<typename T>
  static inline const std::string& ServiceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ServiceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ServiceType_Name.");
    return CubeManagement_ServiceType_Name(enum_t_value);
  }
  static inline bool ServiceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ServiceType* value) {
    return CubeManagement_ServiceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCubeNameFieldNumber = 1,
    kServiceNameFieldNumber = 2,
    kIngressCodeFieldNumber = 5,
    kEgressCodeFieldNumber = 6,
    kLoglevelFieldNumber = 7,
    kConfFieldNumber = 8,
    kUuidFieldNumber = 3,
    kServiceTypeFieldNumber = 4,
  };
  // string cube_name = 1;
  void clear_cube_name();
  const std::string& cube_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cube_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cube_name();
  PROTOBUF_NODISCARD std::string* release_cube_name();
  void set_allocated_cube_name(std::string* cube_name);
  private:
  const std::string& _internal_cube_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cube_name(const std::string& value);
  std::string* _internal_mutable_cube_name();
  public:

  // optional string service_name = 2;
  bool has_service_name() const;
  private:
  bool _internal_has_service_name() const;
  public:
  void clear_service_name();
  const std::string& service_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_name();
  PROTOBUF_NODISCARD std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);
  private:
  const std::string& _internal_service_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_name(const std::string& value);
  std::string* _internal_mutable_service_name();
  public:

  // optional string ingress_code = 5;
  bool has_ingress_code() const;
  private:
  bool _internal_has_ingress_code() const;
  public:
  void clear_ingress_code();
  const std::string& ingress_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ingress_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ingress_code();
  PROTOBUF_NODISCARD std::string* release_ingress_code();
  void set_allocated_ingress_code(std::string* ingress_code);
  private:
  const std::string& _internal_ingress_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ingress_code(const std::string& value);
  std::string* _internal_mutable_ingress_code();
  public:

  // optional string egress_code = 6;
  bool has_egress_code() const;
  private:
  bool _internal_has_egress_code() const;
  public:
  void clear_egress_code();
  const std::string& egress_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_egress_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_egress_code();
  PROTOBUF_NODISCARD std::string* release_egress_code();
  void set_allocated_egress_code(std::string* egress_code);
  private:
  const std::string& _internal_egress_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_egress_code(const std::string& value);
  std::string* _internal_mutable_egress_code();
  public:

  // optional string loglevel = 7;
  bool has_loglevel() const;
  private:
  bool _internal_has_loglevel() const;
  public:
  void clear_loglevel();
  const std::string& loglevel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loglevel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loglevel();
  PROTOBUF_NODISCARD std::string* release_loglevel();
  void set_allocated_loglevel(std::string* loglevel);
  private:
  const std::string& _internal_loglevel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loglevel(const std::string& value);
  std::string* _internal_mutable_loglevel();
  public:

  // optional string conf = 8;
  bool has_conf() const;
  private:
  bool _internal_has_conf() const;
  public:
  void clear_conf();
  const std::string& conf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_conf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_conf();
  PROTOBUF_NODISCARD std::string* release_conf();
  void set_allocated_conf(std::string* conf);
  private:
  const std::string& _internal_conf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_conf(const std::string& value);
  std::string* _internal_mutable_conf();
  public:

  // optional int32 uuid = 3;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  int32_t uuid() const;
  void set_uuid(int32_t value);
  private:
  int32_t _internal_uuid() const;
  void _internal_set_uuid(int32_t value);
  public:

  // optional .commons.CubeManagement.ServiceType service_type = 4;
  bool has_service_type() const;
  private:
  bool _internal_has_service_type() const;
  public:
  void clear_service_type();
  ::commons::CubeManagement_ServiceType service_type() const;
  void set_service_type(::commons::CubeManagement_ServiceType value);
  private:
  ::commons::CubeManagement_ServiceType _internal_service_type() const;
  void _internal_set_service_type(::commons::CubeManagement_ServiceType value);
  public:

  // @@protoc_insertion_point(class_scope:commons.CubeManagement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cube_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ingress_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr egress_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loglevel_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr conf_;
  int32_t uuid_;
  int service_type_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class Port final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.Port) */ {
 public:
  inline Port() : Port(nullptr) {}
  ~Port() override;
  explicit constexpr Port(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Port(const Port& from);
  Port(Port&& from) noexcept
    : Port() {
    *this = ::std::move(from);
  }

  inline Port& operator=(const Port& from) {
    CopyFrom(from);
    return *this;
  }
  inline Port& operator=(Port&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Port& default_instance() {
    return *internal_default_instance();
  }
  static inline const Port* internal_default_instance() {
    return reinterpret_cast<const Port*>(
               &_Port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Port& a, Port& b) {
    a.Swap(&b);
  }
  inline void Swap(Port* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Port* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Port>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Port& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Port& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Port* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.Port";
  }
  protected:
  explicit Port(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Port_PortStatus PortStatus;
  static constexpr PortStatus DOWN =
    Port_PortStatus_DOWN;
  static constexpr PortStatus UP =
    Port_PortStatus_UP;
  static inline bool PortStatus_IsValid(int value) {
    return Port_PortStatus_IsValid(value);
  }
  static constexpr PortStatus PortStatus_MIN =
    Port_PortStatus_PortStatus_MIN;
  static constexpr PortStatus PortStatus_MAX =
    Port_PortStatus_PortStatus_MAX;
  static constexpr int PortStatus_ARRAYSIZE =
    Port_PortStatus_PortStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PortStatus_descriptor() {
    return Port_PortStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& PortStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PortStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PortStatus_Name.");
    return Port_PortStatus_Name(enum_t_value);
  }
  static inline bool PortStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PortStatus* value) {
    return Port_PortStatus_Parse(name, value);
  }

  typedef Port_PortType PortType;
  static constexpr PortType TC =
    Port_PortType_TC;
  static constexpr PortType XDP =
    Port_PortType_XDP;
  static inline bool PortType_IsValid(int value) {
    return Port_PortType_IsValid(value);
  }
  static constexpr PortType PortType_MIN =
    Port_PortType_PortType_MIN;
  static constexpr PortType PortType_MAX =
    Port_PortType_PortType_MAX;
  static constexpr int PortType_ARRAYSIZE =
    Port_PortType_PortType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PortType_descriptor() {
    return Port_PortType_descriptor();
  }
  template<typename T>
  static inline const std::string& PortType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PortType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PortType_Name.");
    return Port_PortType_Name(enum_t_value);
  }
  static inline bool PortType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PortType* value) {
    return Port_PortType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPeerFieldNumber = 2,
    kPortStatusFieldNumber = 3,
    kPortTypeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string peer = 2;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_NODISCARD std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // .commons.Port.PortStatus port_status = 3;
  void clear_port_status();
  ::commons::Port_PortStatus port_status() const;
  void set_port_status(::commons::Port_PortStatus value);
  private:
  ::commons::Port_PortStatus _internal_port_status() const;
  void _internal_set_port_status(::commons::Port_PortStatus value);
  public:

  // .commons.Port.PortType port_type = 4;
  void clear_port_type();
  ::commons::Port_PortType port_type() const;
  void set_port_type(::commons::Port_PortType value);
  private:
  ::commons::Port_PortType _internal_port_type() const;
  void _internal_set_port_type(::commons::Port_PortType value);
  public:

  // @@protoc_insertion_point(class_scope:commons.Port)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  int port_status_;
  int port_type_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class MapValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.MapValue) */ {
 public:
  inline MapValue() : MapValue(nullptr) {}
  ~MapValue() override;
  explicit constexpr MapValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapValue(const MapValue& from);
  MapValue(MapValue&& from) noexcept
    : MapValue() {
    *this = ::std::move(from);
  }

  inline MapValue& operator=(const MapValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapValue& operator=(MapValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapValue* internal_default_instance() {
    return reinterpret_cast<const MapValue*>(
               &_MapValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MapValue& a, MapValue& b) {
    a.Swap(&b);
  }
  inline void Swap(MapValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MapValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.MapValue";
  }
  protected:
  explicit MapValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByteValuesFieldNumber = 1,
    kNameFieldNumber = 2,
    kKeyDescFieldNumber = 8,
    kLeafDescFieldNumber = 9,
    kKeySizeFieldNumber = 4,
    kLeafSizeFieldNumber = 5,
    kTypeFieldNumber = 3,
    kFlagsFieldNumber = 7,
    kMaxEntriesFieldNumber = 6,
    kCounterFieldNumber = 10,
  };
  // bytes byteValues = 1;
  void clear_bytevalues();
  const std::string& bytevalues() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytevalues(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytevalues();
  PROTOBUF_NODISCARD std::string* release_bytevalues();
  void set_allocated_bytevalues(std::string* bytevalues);
  private:
  const std::string& _internal_bytevalues() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytevalues(const std::string& value);
  std::string* _internal_mutable_bytevalues();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string key_desc = 8;
  void clear_key_desc();
  const std::string& key_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_desc();
  PROTOBUF_NODISCARD std::string* release_key_desc();
  void set_allocated_key_desc(std::string* key_desc);
  private:
  const std::string& _internal_key_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_desc(const std::string& value);
  std::string* _internal_mutable_key_desc();
  public:

  // string leaf_desc = 9;
  void clear_leaf_desc();
  const std::string& leaf_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leaf_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leaf_desc();
  PROTOBUF_NODISCARD std::string* release_leaf_desc();
  void set_allocated_leaf_desc(std::string* leaf_desc);
  private:
  const std::string& _internal_leaf_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leaf_desc(const std::string& value);
  std::string* _internal_mutable_leaf_desc();
  public:

  // uint64 key_size = 4;
  void clear_key_size();
  uint64_t key_size() const;
  void set_key_size(uint64_t value);
  private:
  uint64_t _internal_key_size() const;
  void _internal_set_key_size(uint64_t value);
  public:

  // uint64 leaf_size = 5;
  void clear_leaf_size();
  uint64_t leaf_size() const;
  void set_leaf_size(uint64_t value);
  private:
  uint64_t _internal_leaf_size() const;
  void _internal_set_leaf_size(uint64_t value);
  public:

  // int32 type = 3;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // int32 flags = 7;
  void clear_flags();
  int32_t flags() const;
  void set_flags(int32_t value);
  private:
  int32_t _internal_flags() const;
  void _internal_set_flags(int32_t value);
  public:

  // uint64 max_entries = 6;
  void clear_max_entries();
  uint64_t max_entries() const;
  void set_max_entries(uint64_t value);
  private:
  uint64_t _internal_max_entries() const;
  void _internal_set_max_entries(uint64_t value);
  public:

  // optional int32 counter = 10;
  bool has_counter() const;
  private:
  bool _internal_has_counter() const;
  public:
  void clear_counter();
  int32_t counter() const;
  void set_counter(int32_t value);
  private:
  int32_t _internal_counter() const;
  void _internal_set_counter(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:commons.MapValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytevalues_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leaf_desc_;
  uint64_t key_size_;
  uint64_t leaf_size_;
  int32_t type_;
  int32_t flags_;
  uint64_t max_entries_;
  int32_t counter_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class SetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.SetRequest) */ {
 public:
  inline SetRequest() : SetRequest(nullptr) {}
  ~SetRequest() override;
  explicit constexpr SetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetRequest(const SetRequest& from);
  SetRequest(SetRequest&& from) noexcept
    : SetRequest() {
    *this = ::std::move(from);
  }

  inline SetRequest& operator=(const SetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRequest& operator=(SetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetRequest* internal_default_instance() {
    return reinterpret_cast<const SetRequest*>(
               &_SetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetRequest& a, SetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.SetRequest";
  }
  protected:
  explicit SetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 3,
    kKeySizeFieldNumber = 2,
    kValueSizeFieldNumber = 4,
  };
  // bytes key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint64 key_size = 2;
  void clear_key_size();
  uint64_t key_size() const;
  void set_key_size(uint64_t value);
  private:
  uint64_t _internal_key_size() const;
  void _internal_set_key_size(uint64_t value);
  public:

  // uint64 value_size = 4;
  void clear_value_size();
  uint64_t value_size() const;
  void set_value_size(uint64_t value);
  private:
  uint64_t _internal_value_size() const;
  void _internal_set_value_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:commons.SetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  uint64_t key_size_;
  uint64_t value_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  explicit constexpr GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kKeySizeFieldNumber = 3,
    kValueSizeFieldNumber = 4,
    kAllFieldNumber = 1,
  };
  // optional bytes key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 key_size = 3;
  void clear_key_size();
  uint64_t key_size() const;
  void set_key_size(uint64_t value);
  private:
  uint64_t _internal_key_size() const;
  void _internal_set_key_size(uint64_t value);
  public:

  // uint64 value_size = 4;
  void clear_value_size();
  uint64_t value_size() const;
  void set_value_size(uint64_t value);
  private:
  uint64_t _internal_value_size() const;
  void _internal_set_value_size(uint64_t value);
  public:

  // bool all = 1;
  void clear_all();
  bool all() const;
  void set_all(bool value);
  private:
  bool _internal_all() const;
  void _internal_set_all(bool value);
  public:

  // @@protoc_insertion_point(class_scope:commons.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  uint64_t key_size_;
  uint64_t value_size_;
  bool all_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class RemoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.RemoveRequest) */ {
 public:
  inline RemoveRequest() : RemoveRequest(nullptr) {}
  ~RemoveRequest() override;
  explicit constexpr RemoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRequest(const RemoveRequest& from);
  RemoveRequest(RemoveRequest&& from) noexcept
    : RemoveRequest() {
    *this = ::std::move(from);
  }

  inline RemoveRequest& operator=(const RemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRequest& operator=(RemoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveRequest*>(
               &_RemoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RemoveRequest& a, RemoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.RemoveRequest";
  }
  protected:
  explicit RemoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kKeySizeFieldNumber = 3,
    kAllFieldNumber = 1,
  };
  // bytes key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // uint64 key_size = 3;
  void clear_key_size();
  uint64_t key_size() const;
  void set_key_size(uint64_t value);
  private:
  uint64_t _internal_key_size() const;
  void _internal_set_key_size(uint64_t value);
  public:

  // bool all = 1;
  void clear_all();
  bool all() const;
  void set_all(bool value);
  private:
  bool _internal_all() const;
  void _internal_set_all(bool value);
  public:

  // @@protoc_insertion_point(class_scope:commons.RemoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  uint64_t key_size_;
  bool all_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class Index final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.Index) */ {
 public:
  inline Index() : Index(nullptr) {}
  ~Index() override;
  explicit constexpr Index(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Index(const Index& from);
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  inline Index& operator=(Index&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Index& default_instance() {
    return *internal_default_instance();
  }
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }
  inline void Swap(Index* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Index* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Index* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Index& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Index& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.Index";
  }
  protected:
  explicit Index(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // int32 index = 1;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:commons.Index)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// -------------------------------------------------------------------

class Dataplane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:commons.Dataplane) */ {
 public:
  inline Dataplane() : Dataplane(nullptr) {}
  ~Dataplane() override;
  explicit constexpr Dataplane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dataplane(const Dataplane& from);
  Dataplane(Dataplane&& from) noexcept
    : Dataplane() {
    *this = ::std::move(from);
  }

  inline Dataplane& operator=(const Dataplane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dataplane& operator=(Dataplane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dataplane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dataplane* internal_default_instance() {
    return reinterpret_cast<const Dataplane*>(
               &_Dataplane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Dataplane& a, Dataplane& b) {
    a.Swap(&b);
  }
  inline void Swap(Dataplane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dataplane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dataplane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dataplane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dataplane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Dataplane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dataplane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "commons.Dataplane";
  }
  protected:
  explicit Dataplane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Dataplane_ProgramType ProgramType;
  static constexpr ProgramType INGRESS =
    Dataplane_ProgramType_INGRESS;
  static constexpr ProgramType EGRESS =
    Dataplane_ProgramType_EGRESS;
  static inline bool ProgramType_IsValid(int value) {
    return Dataplane_ProgramType_IsValid(value);
  }
  static constexpr ProgramType ProgramType_MIN =
    Dataplane_ProgramType_ProgramType_MIN;
  static constexpr ProgramType ProgramType_MAX =
    Dataplane_ProgramType_ProgramType_MAX;
  static constexpr int ProgramType_ARRAYSIZE =
    Dataplane_ProgramType_ProgramType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProgramType_descriptor() {
    return Dataplane_ProgramType_descriptor();
  }
  template<typename T>
  static inline const std::string& ProgramType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProgramType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProgramType_Name.");
    return Dataplane_ProgramType_Name(enum_t_value);
  }
  static inline bool ProgramType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProgramType* value) {
    return Dataplane_ProgramType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCubeNameFieldNumber = 1,
    kCodeFieldNumber = 2,
    kIndexFieldNumber = 3,
    kProgramTypeFieldNumber = 4,
  };
  // string cube_name = 1;
  void clear_cube_name();
  const std::string& cube_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cube_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cube_name();
  PROTOBUF_NODISCARD std::string* release_cube_name();
  void set_allocated_cube_name(std::string* cube_name);
  private:
  const std::string& _internal_cube_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cube_name(const std::string& value);
  std::string* _internal_mutable_cube_name();
  public:

  // optional string code = 2;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // int32 index = 3;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // .commons.Dataplane.ProgramType program_type = 4;
  void clear_program_type();
  ::commons::Dataplane_ProgramType program_type() const;
  void set_program_type(::commons::Dataplane_ProgramType value);
  private:
  ::commons::Dataplane_ProgramType _internal_program_type() const;
  void _internal_set_program_type(::commons::Dataplane_ProgramType value);
  public:

  // @@protoc_insertion_point(class_scope:commons.Dataplane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cube_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  int32_t index_;
  int program_type_;
  friend struct ::TableStruct_polycube_5fgrpc_5fcommons_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Bool

// bool status = 1;
inline void Bool::clear_status() {
  status_ = false;
}
inline bool Bool::_internal_status() const {
  return status_;
}
inline bool Bool::status() const {
  // @@protoc_insertion_point(field_get:commons.Bool.status)
  return _internal_status();
}
inline void Bool::_internal_set_status(bool value) {
  
  status_ = value;
}
inline void Bool::set_status(bool value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:commons.Bool.status)
}

// -------------------------------------------------------------------

// ServicedInfo

// string service_name = 1;
inline void ServicedInfo::clear_service_name() {
  service_name_.ClearToEmpty();
}
inline const std::string& ServicedInfo::service_name() const {
  // @@protoc_insertion_point(field_get:commons.ServicedInfo.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServicedInfo::set_service_name(ArgT0&& arg0, ArgT... args) {
 
 service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.ServicedInfo.service_name)
}
inline std::string* ServicedInfo::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:commons.ServicedInfo.service_name)
  return _s;
}
inline const std::string& ServicedInfo::_internal_service_name() const {
  return service_name_.Get();
}
inline void ServicedInfo::_internal_set_service_name(const std::string& value) {
  
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServicedInfo::_internal_mutable_service_name() {
  
  return service_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServicedInfo::release_service_name() {
  // @@protoc_insertion_point(field_release:commons.ServicedInfo.service_name)
  return service_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServicedInfo::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    
  } else {
    
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedInfo.service_name)
}

// int32 uuid = 2;
inline void ServicedInfo::clear_uuid() {
  uuid_ = 0;
}
inline int32_t ServicedInfo::_internal_uuid() const {
  return uuid_;
}
inline int32_t ServicedInfo::uuid() const {
  // @@protoc_insertion_point(field_get:commons.ServicedInfo.uuid)
  return _internal_uuid();
}
inline void ServicedInfo::_internal_set_uuid(int32_t value) {
  
  uuid_ = value;
}
inline void ServicedInfo::set_uuid(int32_t value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:commons.ServicedInfo.uuid)
}

// optional .commons.ServicedInfo.ServiceType service_type = 3;
inline bool ServicedInfo::_internal_has_service_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ServicedInfo::has_service_type() const {
  return _internal_has_service_type();
}
inline void ServicedInfo::clear_service_type() {
  service_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::commons::ServicedInfo_ServiceType ServicedInfo::_internal_service_type() const {
  return static_cast< ::commons::ServicedInfo_ServiceType >(service_type_);
}
inline ::commons::ServicedInfo_ServiceType ServicedInfo::service_type() const {
  // @@protoc_insertion_point(field_get:commons.ServicedInfo.service_type)
  return _internal_service_type();
}
inline void ServicedInfo::_internal_set_service_type(::commons::ServicedInfo_ServiceType value) {
  _has_bits_[0] |= 0x00000008u;
  service_type_ = value;
}
inline void ServicedInfo::set_service_type(::commons::ServicedInfo_ServiceType value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:commons.ServicedInfo.service_type)
}

// optional string cube_name = 4;
inline bool ServicedInfo::_internal_has_cube_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServicedInfo::has_cube_name() const {
  return _internal_has_cube_name();
}
inline void ServicedInfo::clear_cube_name() {
  cube_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServicedInfo::cube_name() const {
  // @@protoc_insertion_point(field_get:commons.ServicedInfo.cube_name)
  return _internal_cube_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServicedInfo::set_cube_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.ServicedInfo.cube_name)
}
inline std::string* ServicedInfo::mutable_cube_name() {
  std::string* _s = _internal_mutable_cube_name();
  // @@protoc_insertion_point(field_mutable:commons.ServicedInfo.cube_name)
  return _s;
}
inline const std::string& ServicedInfo::_internal_cube_name() const {
  return cube_name_.Get();
}
inline void ServicedInfo::_internal_set_cube_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServicedInfo::_internal_mutable_cube_name() {
  _has_bits_[0] |= 0x00000001u;
  return cube_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServicedInfo::release_cube_name() {
  // @@protoc_insertion_point(field_release:commons.ServicedInfo.cube_name)
  if (!_internal_has_cube_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cube_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cube_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cube_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServicedInfo::set_allocated_cube_name(std::string* cube_name) {
  if (cube_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cube_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cube_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cube_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cube_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedInfo.cube_name)
}

// optional string port_name = 5;
inline bool ServicedInfo::_internal_has_port_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServicedInfo::has_port_name() const {
  return _internal_has_port_name();
}
inline void ServicedInfo::clear_port_name() {
  port_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServicedInfo::port_name() const {
  // @@protoc_insertion_point(field_get:commons.ServicedInfo.port_name)
  return _internal_port_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServicedInfo::set_port_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 port_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.ServicedInfo.port_name)
}
inline std::string* ServicedInfo::mutable_port_name() {
  std::string* _s = _internal_mutable_port_name();
  // @@protoc_insertion_point(field_mutable:commons.ServicedInfo.port_name)
  return _s;
}
inline const std::string& ServicedInfo::_internal_port_name() const {
  return port_name_.Get();
}
inline void ServicedInfo::_internal_set_port_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  port_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServicedInfo::_internal_mutable_port_name() {
  _has_bits_[0] |= 0x00000002u;
  return port_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServicedInfo::release_port_name() {
  // @@protoc_insertion_point(field_release:commons.ServicedInfo.port_name)
  if (!_internal_has_port_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = port_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    port_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServicedInfo::set_allocated_port_name(std::string* port_name) {
  if (port_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  port_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), port_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (port_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    port_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedInfo.port_name)
}

// optional string peer_name = 6;
inline bool ServicedInfo::_internal_has_peer_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ServicedInfo::has_peer_name() const {
  return _internal_has_peer_name();
}
inline void ServicedInfo::clear_peer_name() {
  peer_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ServicedInfo::peer_name() const {
  // @@protoc_insertion_point(field_get:commons.ServicedInfo.peer_name)
  return _internal_peer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServicedInfo::set_peer_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 peer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.ServicedInfo.peer_name)
}
inline std::string* ServicedInfo::mutable_peer_name() {
  std::string* _s = _internal_mutable_peer_name();
  // @@protoc_insertion_point(field_mutable:commons.ServicedInfo.peer_name)
  return _s;
}
inline const std::string& ServicedInfo::_internal_peer_name() const {
  return peer_name_.Get();
}
inline void ServicedInfo::_internal_set_peer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  peer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServicedInfo::_internal_mutable_peer_name() {
  _has_bits_[0] |= 0x00000004u;
  return peer_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServicedInfo::release_peer_name() {
  // @@protoc_insertion_point(field_release:commons.ServicedInfo.peer_name)
  if (!_internal_has_peer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = peer_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServicedInfo::set_allocated_peer_name(std::string* peer_name) {
  if (peer_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  peer_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedInfo.peer_name)
}

// -------------------------------------------------------------------

// ToServiced

// .commons.ServicedInfo serviced_info = 1;
inline bool ToServiced::_internal_has_serviced_info() const {
  return this != internal_default_instance() && serviced_info_ != nullptr;
}
inline bool ToServiced::has_serviced_info() const {
  return _internal_has_serviced_info();
}
inline void ToServiced::clear_serviced_info() {
  if (GetArenaForAllocation() == nullptr && serviced_info_ != nullptr) {
    delete serviced_info_;
  }
  serviced_info_ = nullptr;
}
inline const ::commons::ServicedInfo& ToServiced::_internal_serviced_info() const {
  const ::commons::ServicedInfo* p = serviced_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::commons::ServicedInfo&>(
      ::commons::_ServicedInfo_default_instance_);
}
inline const ::commons::ServicedInfo& ToServiced::serviced_info() const {
  // @@protoc_insertion_point(field_get:commons.ToServiced.serviced_info)
  return _internal_serviced_info();
}
inline void ToServiced::unsafe_arena_set_allocated_serviced_info(
    ::commons::ServicedInfo* serviced_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(serviced_info_);
  }
  serviced_info_ = serviced_info;
  if (serviced_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ToServiced.serviced_info)
}
inline ::commons::ServicedInfo* ToServiced::release_serviced_info() {
  
  ::commons::ServicedInfo* temp = serviced_info_;
  serviced_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commons::ServicedInfo* ToServiced::unsafe_arena_release_serviced_info() {
  // @@protoc_insertion_point(field_release:commons.ToServiced.serviced_info)
  
  ::commons::ServicedInfo* temp = serviced_info_;
  serviced_info_ = nullptr;
  return temp;
}
inline ::commons::ServicedInfo* ToServiced::_internal_mutable_serviced_info() {
  
  if (serviced_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::commons::ServicedInfo>(GetArenaForAllocation());
    serviced_info_ = p;
  }
  return serviced_info_;
}
inline ::commons::ServicedInfo* ToServiced::mutable_serviced_info() {
  ::commons::ServicedInfo* _msg = _internal_mutable_serviced_info();
  // @@protoc_insertion_point(field_mutable:commons.ToServiced.serviced_info)
  return _msg;
}
inline void ToServiced::set_allocated_serviced_info(::commons::ServicedInfo* serviced_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete serviced_info_;
  }
  if (serviced_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::commons::ServicedInfo>::GetOwningArena(serviced_info);
    if (message_arena != submessage_arena) {
      serviced_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serviced_info, submessage_arena);
    }
    
  } else {
    
  }
  serviced_info_ = serviced_info;
  // @@protoc_insertion_point(field_set_allocated:commons.ToServiced.serviced_info)
}

// .commons.DataplaneToServicedRequest dataplane_to_serviced_request = 2;
inline bool ToServiced::_internal_has_dataplane_to_serviced_request() const {
  return to_serviced_case() == kDataplaneToServicedRequest;
}
inline bool ToServiced::has_dataplane_to_serviced_request() const {
  return _internal_has_dataplane_to_serviced_request();
}
inline void ToServiced::set_has_dataplane_to_serviced_request() {
  _oneof_case_[0] = kDataplaneToServicedRequest;
}
inline void ToServiced::clear_dataplane_to_serviced_request() {
  if (_internal_has_dataplane_to_serviced_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete to_serviced_.dataplane_to_serviced_request_;
    }
    clear_has_to_serviced();
  }
}
inline ::commons::DataplaneToServicedRequest* ToServiced::release_dataplane_to_serviced_request() {
  // @@protoc_insertion_point(field_release:commons.ToServiced.dataplane_to_serviced_request)
  if (_internal_has_dataplane_to_serviced_request()) {
    clear_has_to_serviced();
      ::commons::DataplaneToServicedRequest* temp = to_serviced_.dataplane_to_serviced_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    to_serviced_.dataplane_to_serviced_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::DataplaneToServicedRequest& ToServiced::_internal_dataplane_to_serviced_request() const {
  return _internal_has_dataplane_to_serviced_request()
      ? *to_serviced_.dataplane_to_serviced_request_
      : reinterpret_cast< ::commons::DataplaneToServicedRequest&>(::commons::_DataplaneToServicedRequest_default_instance_);
}
inline const ::commons::DataplaneToServicedRequest& ToServiced::dataplane_to_serviced_request() const {
  // @@protoc_insertion_point(field_get:commons.ToServiced.dataplane_to_serviced_request)
  return _internal_dataplane_to_serviced_request();
}
inline ::commons::DataplaneToServicedRequest* ToServiced::unsafe_arena_release_dataplane_to_serviced_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ToServiced.dataplane_to_serviced_request)
  if (_internal_has_dataplane_to_serviced_request()) {
    clear_has_to_serviced();
    ::commons::DataplaneToServicedRequest* temp = to_serviced_.dataplane_to_serviced_request_;
    to_serviced_.dataplane_to_serviced_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToServiced::unsafe_arena_set_allocated_dataplane_to_serviced_request(::commons::DataplaneToServicedRequest* dataplane_to_serviced_request) {
  clear_to_serviced();
  if (dataplane_to_serviced_request) {
    set_has_dataplane_to_serviced_request();
    to_serviced_.dataplane_to_serviced_request_ = dataplane_to_serviced_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ToServiced.dataplane_to_serviced_request)
}
inline ::commons::DataplaneToServicedRequest* ToServiced::_internal_mutable_dataplane_to_serviced_request() {
  if (!_internal_has_dataplane_to_serviced_request()) {
    clear_to_serviced();
    set_has_dataplane_to_serviced_request();
    to_serviced_.dataplane_to_serviced_request_ = CreateMaybeMessage< ::commons::DataplaneToServicedRequest >(GetArenaForAllocation());
  }
  return to_serviced_.dataplane_to_serviced_request_;
}
inline ::commons::DataplaneToServicedRequest* ToServiced::mutable_dataplane_to_serviced_request() {
  ::commons::DataplaneToServicedRequest* _msg = _internal_mutable_dataplane_to_serviced_request();
  // @@protoc_insertion_point(field_mutable:commons.ToServiced.dataplane_to_serviced_request)
  return _msg;
}

// .commons.RestUserToServicedRequest rest_user_to_service_request = 3;
inline bool ToServiced::_internal_has_rest_user_to_service_request() const {
  return to_serviced_case() == kRestUserToServiceRequest;
}
inline bool ToServiced::has_rest_user_to_service_request() const {
  return _internal_has_rest_user_to_service_request();
}
inline void ToServiced::set_has_rest_user_to_service_request() {
  _oneof_case_[0] = kRestUserToServiceRequest;
}
inline void ToServiced::clear_rest_user_to_service_request() {
  if (_internal_has_rest_user_to_service_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete to_serviced_.rest_user_to_service_request_;
    }
    clear_has_to_serviced();
  }
}
inline ::commons::RestUserToServicedRequest* ToServiced::release_rest_user_to_service_request() {
  // @@protoc_insertion_point(field_release:commons.ToServiced.rest_user_to_service_request)
  if (_internal_has_rest_user_to_service_request()) {
    clear_has_to_serviced();
      ::commons::RestUserToServicedRequest* temp = to_serviced_.rest_user_to_service_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    to_serviced_.rest_user_to_service_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::RestUserToServicedRequest& ToServiced::_internal_rest_user_to_service_request() const {
  return _internal_has_rest_user_to_service_request()
      ? *to_serviced_.rest_user_to_service_request_
      : reinterpret_cast< ::commons::RestUserToServicedRequest&>(::commons::_RestUserToServicedRequest_default_instance_);
}
inline const ::commons::RestUserToServicedRequest& ToServiced::rest_user_to_service_request() const {
  // @@protoc_insertion_point(field_get:commons.ToServiced.rest_user_to_service_request)
  return _internal_rest_user_to_service_request();
}
inline ::commons::RestUserToServicedRequest* ToServiced::unsafe_arena_release_rest_user_to_service_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ToServiced.rest_user_to_service_request)
  if (_internal_has_rest_user_to_service_request()) {
    clear_has_to_serviced();
    ::commons::RestUserToServicedRequest* temp = to_serviced_.rest_user_to_service_request_;
    to_serviced_.rest_user_to_service_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToServiced::unsafe_arena_set_allocated_rest_user_to_service_request(::commons::RestUserToServicedRequest* rest_user_to_service_request) {
  clear_to_serviced();
  if (rest_user_to_service_request) {
    set_has_rest_user_to_service_request();
    to_serviced_.rest_user_to_service_request_ = rest_user_to_service_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ToServiced.rest_user_to_service_request)
}
inline ::commons::RestUserToServicedRequest* ToServiced::_internal_mutable_rest_user_to_service_request() {
  if (!_internal_has_rest_user_to_service_request()) {
    clear_to_serviced();
    set_has_rest_user_to_service_request();
    to_serviced_.rest_user_to_service_request_ = CreateMaybeMessage< ::commons::RestUserToServicedRequest >(GetArenaForAllocation());
  }
  return to_serviced_.rest_user_to_service_request_;
}
inline ::commons::RestUserToServicedRequest* ToServiced::mutable_rest_user_to_service_request() {
  ::commons::RestUserToServicedRequest* _msg = _internal_mutable_rest_user_to_service_request();
  // @@protoc_insertion_point(field_mutable:commons.ToServiced.rest_user_to_service_request)
  return _msg;
}

// .commons.DataplaneToServicedPacket dataplane_to_serviced_packet = 4;
inline bool ToServiced::_internal_has_dataplane_to_serviced_packet() const {
  return to_serviced_case() == kDataplaneToServicedPacket;
}
inline bool ToServiced::has_dataplane_to_serviced_packet() const {
  return _internal_has_dataplane_to_serviced_packet();
}
inline void ToServiced::set_has_dataplane_to_serviced_packet() {
  _oneof_case_[0] = kDataplaneToServicedPacket;
}
inline void ToServiced::clear_dataplane_to_serviced_packet() {
  if (_internal_has_dataplane_to_serviced_packet()) {
    if (GetArenaForAllocation() == nullptr) {
      delete to_serviced_.dataplane_to_serviced_packet_;
    }
    clear_has_to_serviced();
  }
}
inline ::commons::DataplaneToServicedPacket* ToServiced::release_dataplane_to_serviced_packet() {
  // @@protoc_insertion_point(field_release:commons.ToServiced.dataplane_to_serviced_packet)
  if (_internal_has_dataplane_to_serviced_packet()) {
    clear_has_to_serviced();
      ::commons::DataplaneToServicedPacket* temp = to_serviced_.dataplane_to_serviced_packet_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    to_serviced_.dataplane_to_serviced_packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::DataplaneToServicedPacket& ToServiced::_internal_dataplane_to_serviced_packet() const {
  return _internal_has_dataplane_to_serviced_packet()
      ? *to_serviced_.dataplane_to_serviced_packet_
      : reinterpret_cast< ::commons::DataplaneToServicedPacket&>(::commons::_DataplaneToServicedPacket_default_instance_);
}
inline const ::commons::DataplaneToServicedPacket& ToServiced::dataplane_to_serviced_packet() const {
  // @@protoc_insertion_point(field_get:commons.ToServiced.dataplane_to_serviced_packet)
  return _internal_dataplane_to_serviced_packet();
}
inline ::commons::DataplaneToServicedPacket* ToServiced::unsafe_arena_release_dataplane_to_serviced_packet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ToServiced.dataplane_to_serviced_packet)
  if (_internal_has_dataplane_to_serviced_packet()) {
    clear_has_to_serviced();
    ::commons::DataplaneToServicedPacket* temp = to_serviced_.dataplane_to_serviced_packet_;
    to_serviced_.dataplane_to_serviced_packet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToServiced::unsafe_arena_set_allocated_dataplane_to_serviced_packet(::commons::DataplaneToServicedPacket* dataplane_to_serviced_packet) {
  clear_to_serviced();
  if (dataplane_to_serviced_packet) {
    set_has_dataplane_to_serviced_packet();
    to_serviced_.dataplane_to_serviced_packet_ = dataplane_to_serviced_packet;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ToServiced.dataplane_to_serviced_packet)
}
inline ::commons::DataplaneToServicedPacket* ToServiced::_internal_mutable_dataplane_to_serviced_packet() {
  if (!_internal_has_dataplane_to_serviced_packet()) {
    clear_to_serviced();
    set_has_dataplane_to_serviced_packet();
    to_serviced_.dataplane_to_serviced_packet_ = CreateMaybeMessage< ::commons::DataplaneToServicedPacket >(GetArenaForAllocation());
  }
  return to_serviced_.dataplane_to_serviced_packet_;
}
inline ::commons::DataplaneToServicedPacket* ToServiced::mutable_dataplane_to_serviced_packet() {
  ::commons::DataplaneToServicedPacket* _msg = _internal_mutable_dataplane_to_serviced_packet();
  // @@protoc_insertion_point(field_mutable:commons.ToServiced.dataplane_to_serviced_packet)
  return _msg;
}

inline bool ToServiced::has_to_serviced() const {
  return to_serviced_case() != TO_SERVICED_NOT_SET;
}
inline void ToServiced::clear_has_to_serviced() {
  _oneof_case_[0] = TO_SERVICED_NOT_SET;
}
inline ToServiced::ToServicedCase ToServiced::to_serviced_case() const {
  return ToServiced::ToServicedCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RestUserToServicedRequest

// string http_verb = 1;
inline void RestUserToServicedRequest::clear_http_verb() {
  http_verb_.ClearToEmpty();
}
inline const std::string& RestUserToServicedRequest::http_verb() const {
  // @@protoc_insertion_point(field_get:commons.RestUserToServicedRequest.http_verb)
  return _internal_http_verb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestUserToServicedRequest::set_http_verb(ArgT0&& arg0, ArgT... args) {
 
 http_verb_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.RestUserToServicedRequest.http_verb)
}
inline std::string* RestUserToServicedRequest::mutable_http_verb() {
  std::string* _s = _internal_mutable_http_verb();
  // @@protoc_insertion_point(field_mutable:commons.RestUserToServicedRequest.http_verb)
  return _s;
}
inline const std::string& RestUserToServicedRequest::_internal_http_verb() const {
  return http_verb_.Get();
}
inline void RestUserToServicedRequest::_internal_set_http_verb(const std::string& value) {
  
  http_verb_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RestUserToServicedRequest::_internal_mutable_http_verb() {
  
  return http_verb_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RestUserToServicedRequest::release_http_verb() {
  // @@protoc_insertion_point(field_release:commons.RestUserToServicedRequest.http_verb)
  return http_verb_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RestUserToServicedRequest::set_allocated_http_verb(std::string* http_verb) {
  if (http_verb != nullptr) {
    
  } else {
    
  }
  http_verb_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), http_verb,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (http_verb_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    http_verb_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.RestUserToServicedRequest.http_verb)
}

// string url = 2;
inline void RestUserToServicedRequest::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& RestUserToServicedRequest::url() const {
  // @@protoc_insertion_point(field_get:commons.RestUserToServicedRequest.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestUserToServicedRequest::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.RestUserToServicedRequest.url)
}
inline std::string* RestUserToServicedRequest::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:commons.RestUserToServicedRequest.url)
  return _s;
}
inline const std::string& RestUserToServicedRequest::_internal_url() const {
  return url_.Get();
}
inline void RestUserToServicedRequest::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RestUserToServicedRequest::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RestUserToServicedRequest::release_url() {
  // @@protoc_insertion_point(field_release:commons.RestUserToServicedRequest.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RestUserToServicedRequest::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.RestUserToServicedRequest.url)
}

// optional string request_body = 3;
inline bool RestUserToServicedRequest::_internal_has_request_body() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RestUserToServicedRequest::has_request_body() const {
  return _internal_has_request_body();
}
inline void RestUserToServicedRequest::clear_request_body() {
  request_body_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RestUserToServicedRequest::request_body() const {
  // @@protoc_insertion_point(field_get:commons.RestUserToServicedRequest.request_body)
  return _internal_request_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RestUserToServicedRequest::set_request_body(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 request_body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.RestUserToServicedRequest.request_body)
}
inline std::string* RestUserToServicedRequest::mutable_request_body() {
  std::string* _s = _internal_mutable_request_body();
  // @@protoc_insertion_point(field_mutable:commons.RestUserToServicedRequest.request_body)
  return _s;
}
inline const std::string& RestUserToServicedRequest::_internal_request_body() const {
  return request_body_.Get();
}
inline void RestUserToServicedRequest::_internal_set_request_body(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  request_body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RestUserToServicedRequest::_internal_mutable_request_body() {
  _has_bits_[0] |= 0x00000001u;
  return request_body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RestUserToServicedRequest::release_request_body() {
  // @@protoc_insertion_point(field_release:commons.RestUserToServicedRequest.request_body)
  if (!_internal_has_request_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = request_body_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RestUserToServicedRequest::set_allocated_request_body(std::string* request_body) {
  if (request_body != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  request_body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.RestUserToServicedRequest.request_body)
}

// -------------------------------------------------------------------

// DataplaneToServicedRequest

// string controlplane_method = 1;
inline void DataplaneToServicedRequest::clear_controlplane_method() {
  controlplane_method_.ClearToEmpty();
}
inline const std::string& DataplaneToServicedRequest::controlplane_method() const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedRequest.controlplane_method)
  return _internal_controlplane_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataplaneToServicedRequest::set_controlplane_method(ArgT0&& arg0, ArgT... args) {
 
 controlplane_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedRequest.controlplane_method)
}
inline std::string* DataplaneToServicedRequest::mutable_controlplane_method() {
  std::string* _s = _internal_mutable_controlplane_method();
  // @@protoc_insertion_point(field_mutable:commons.DataplaneToServicedRequest.controlplane_method)
  return _s;
}
inline const std::string& DataplaneToServicedRequest::_internal_controlplane_method() const {
  return controlplane_method_.Get();
}
inline void DataplaneToServicedRequest::_internal_set_controlplane_method(const std::string& value) {
  
  controlplane_method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataplaneToServicedRequest::_internal_mutable_controlplane_method() {
  
  return controlplane_method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataplaneToServicedRequest::release_controlplane_method() {
  // @@protoc_insertion_point(field_release:commons.DataplaneToServicedRequest.controlplane_method)
  return controlplane_method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataplaneToServicedRequest::set_allocated_controlplane_method(std::string* controlplane_method) {
  if (controlplane_method != nullptr) {
    
  } else {
    
  }
  controlplane_method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controlplane_method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controlplane_method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controlplane_method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.DataplaneToServicedRequest.controlplane_method)
}

// repeated bytes parameters = 2;
inline int DataplaneToServicedRequest::_internal_parameters_size() const {
  return parameters_.size();
}
inline int DataplaneToServicedRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void DataplaneToServicedRequest::clear_parameters() {
  parameters_.Clear();
}
inline std::string* DataplaneToServicedRequest::add_parameters() {
  std::string* _s = _internal_add_parameters();
  // @@protoc_insertion_point(field_add_mutable:commons.DataplaneToServicedRequest.parameters)
  return _s;
}
inline const std::string& DataplaneToServicedRequest::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const std::string& DataplaneToServicedRequest::parameters(int index) const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedRequest.parameters)
  return _internal_parameters(index);
}
inline std::string* DataplaneToServicedRequest::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:commons.DataplaneToServicedRequest.parameters)
  return parameters_.Mutable(index);
}
inline void DataplaneToServicedRequest::set_parameters(int index, const std::string& value) {
  parameters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedRequest.parameters)
}
inline void DataplaneToServicedRequest::set_parameters(int index, std::string&& value) {
  parameters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedRequest.parameters)
}
inline void DataplaneToServicedRequest::set_parameters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  parameters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:commons.DataplaneToServicedRequest.parameters)
}
inline void DataplaneToServicedRequest::set_parameters(int index, const void* value, size_t size) {
  parameters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:commons.DataplaneToServicedRequest.parameters)
}
inline std::string* DataplaneToServicedRequest::_internal_add_parameters() {
  return parameters_.Add();
}
inline void DataplaneToServicedRequest::add_parameters(const std::string& value) {
  parameters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:commons.DataplaneToServicedRequest.parameters)
}
inline void DataplaneToServicedRequest::add_parameters(std::string&& value) {
  parameters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:commons.DataplaneToServicedRequest.parameters)
}
inline void DataplaneToServicedRequest::add_parameters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  parameters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:commons.DataplaneToServicedRequest.parameters)
}
inline void DataplaneToServicedRequest::add_parameters(const void* value, size_t size) {
  parameters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:commons.DataplaneToServicedRequest.parameters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataplaneToServicedRequest::parameters() const {
  // @@protoc_insertion_point(field_list:commons.DataplaneToServicedRequest.parameters)
  return parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataplaneToServicedRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:commons.DataplaneToServicedRequest.parameters)
  return &parameters_;
}

// -------------------------------------------------------------------

// DataplaneToServicedPacket

// uint32 cube_id = 1;
inline void DataplaneToServicedPacket::clear_cube_id() {
  cube_id_ = 0u;
}
inline uint32_t DataplaneToServicedPacket::_internal_cube_id() const {
  return cube_id_;
}
inline uint32_t DataplaneToServicedPacket::cube_id() const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedPacket.cube_id)
  return _internal_cube_id();
}
inline void DataplaneToServicedPacket::_internal_set_cube_id(uint32_t value) {
  
  cube_id_ = value;
}
inline void DataplaneToServicedPacket::set_cube_id(uint32_t value) {
  _internal_set_cube_id(value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedPacket.cube_id)
}

// uint32 port_id = 2;
inline void DataplaneToServicedPacket::clear_port_id() {
  port_id_ = 0u;
}
inline uint32_t DataplaneToServicedPacket::_internal_port_id() const {
  return port_id_;
}
inline uint32_t DataplaneToServicedPacket::port_id() const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedPacket.port_id)
  return _internal_port_id();
}
inline void DataplaneToServicedPacket::_internal_set_port_id(uint32_t value) {
  
  port_id_ = value;
}
inline void DataplaneToServicedPacket::set_port_id(uint32_t value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedPacket.port_id)
}

// uint32 packet_len = 3;
inline void DataplaneToServicedPacket::clear_packet_len() {
  packet_len_ = 0u;
}
inline uint32_t DataplaneToServicedPacket::_internal_packet_len() const {
  return packet_len_;
}
inline uint32_t DataplaneToServicedPacket::packet_len() const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedPacket.packet_len)
  return _internal_packet_len();
}
inline void DataplaneToServicedPacket::_internal_set_packet_len(uint32_t value) {
  
  packet_len_ = value;
}
inline void DataplaneToServicedPacket::set_packet_len(uint32_t value) {
  _internal_set_packet_len(value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedPacket.packet_len)
}

// uint32 traffic_class = 4;
inline void DataplaneToServicedPacket::clear_traffic_class() {
  traffic_class_ = 0u;
}
inline uint32_t DataplaneToServicedPacket::_internal_traffic_class() const {
  return traffic_class_;
}
inline uint32_t DataplaneToServicedPacket::traffic_class() const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedPacket.traffic_class)
  return _internal_traffic_class();
}
inline void DataplaneToServicedPacket::_internal_set_traffic_class(uint32_t value) {
  
  traffic_class_ = value;
}
inline void DataplaneToServicedPacket::set_traffic_class(uint32_t value) {
  _internal_set_traffic_class(value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedPacket.traffic_class)
}

// uint32 reason = 5;
inline void DataplaneToServicedPacket::clear_reason() {
  reason_ = 0u;
}
inline uint32_t DataplaneToServicedPacket::_internal_reason() const {
  return reason_;
}
inline uint32_t DataplaneToServicedPacket::reason() const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedPacket.reason)
  return _internal_reason();
}
inline void DataplaneToServicedPacket::_internal_set_reason(uint32_t value) {
  
  reason_ = value;
}
inline void DataplaneToServicedPacket::set_reason(uint32_t value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedPacket.reason)
}

// repeated uint32 metadata = 6;
inline int DataplaneToServicedPacket::_internal_metadata_size() const {
  return metadata_.size();
}
inline int DataplaneToServicedPacket::metadata_size() const {
  return _internal_metadata_size();
}
inline void DataplaneToServicedPacket::clear_metadata() {
  metadata_.Clear();
}
inline uint32_t DataplaneToServicedPacket::_internal_metadata(int index) const {
  return metadata_.Get(index);
}
inline uint32_t DataplaneToServicedPacket::metadata(int index) const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedPacket.metadata)
  return _internal_metadata(index);
}
inline void DataplaneToServicedPacket::set_metadata(int index, uint32_t value) {
  metadata_.Set(index, value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedPacket.metadata)
}
inline void DataplaneToServicedPacket::_internal_add_metadata(uint32_t value) {
  metadata_.Add(value);
}
inline void DataplaneToServicedPacket::add_metadata(uint32_t value) {
  _internal_add_metadata(value);
  // @@protoc_insertion_point(field_add:commons.DataplaneToServicedPacket.metadata)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
DataplaneToServicedPacket::_internal_metadata() const {
  return metadata_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
DataplaneToServicedPacket::metadata() const {
  // @@protoc_insertion_point(field_list:commons.DataplaneToServicedPacket.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
DataplaneToServicedPacket::_internal_mutable_metadata() {
  return &metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
DataplaneToServicedPacket::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:commons.DataplaneToServicedPacket.metadata)
  return _internal_mutable_metadata();
}

// repeated uint32 packet = 7;
inline int DataplaneToServicedPacket::_internal_packet_size() const {
  return packet_.size();
}
inline int DataplaneToServicedPacket::packet_size() const {
  return _internal_packet_size();
}
inline void DataplaneToServicedPacket::clear_packet() {
  packet_.Clear();
}
inline uint32_t DataplaneToServicedPacket::_internal_packet(int index) const {
  return packet_.Get(index);
}
inline uint32_t DataplaneToServicedPacket::packet(int index) const {
  // @@protoc_insertion_point(field_get:commons.DataplaneToServicedPacket.packet)
  return _internal_packet(index);
}
inline void DataplaneToServicedPacket::set_packet(int index, uint32_t value) {
  packet_.Set(index, value);
  // @@protoc_insertion_point(field_set:commons.DataplaneToServicedPacket.packet)
}
inline void DataplaneToServicedPacket::_internal_add_packet(uint32_t value) {
  packet_.Add(value);
}
inline void DataplaneToServicedPacket::add_packet(uint32_t value) {
  _internal_add_packet(value);
  // @@protoc_insertion_point(field_add:commons.DataplaneToServicedPacket.packet)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
DataplaneToServicedPacket::_internal_packet() const {
  return packet_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
DataplaneToServicedPacket::packet() const {
  // @@protoc_insertion_point(field_list:commons.DataplaneToServicedPacket.packet)
  return _internal_packet();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
DataplaneToServicedPacket::_internal_mutable_packet() {
  return &packet_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
DataplaneToServicedPacket::mutable_packet() {
  // @@protoc_insertion_point(field_mutable_list:commons.DataplaneToServicedPacket.packet)
  return _internal_mutable_packet();
}

// -------------------------------------------------------------------

// ToPolycubed

// .commons.ServicedInfo serviced_info = 1;
inline bool ToPolycubed::_internal_has_serviced_info() const {
  return this != internal_default_instance() && serviced_info_ != nullptr;
}
inline bool ToPolycubed::has_serviced_info() const {
  return _internal_has_serviced_info();
}
inline void ToPolycubed::clear_serviced_info() {
  if (GetArenaForAllocation() == nullptr && serviced_info_ != nullptr) {
    delete serviced_info_;
  }
  serviced_info_ = nullptr;
}
inline const ::commons::ServicedInfo& ToPolycubed::_internal_serviced_info() const {
  const ::commons::ServicedInfo* p = serviced_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::commons::ServicedInfo&>(
      ::commons::_ServicedInfo_default_instance_);
}
inline const ::commons::ServicedInfo& ToPolycubed::serviced_info() const {
  // @@protoc_insertion_point(field_get:commons.ToPolycubed.serviced_info)
  return _internal_serviced_info();
}
inline void ToPolycubed::unsafe_arena_set_allocated_serviced_info(
    ::commons::ServicedInfo* serviced_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(serviced_info_);
  }
  serviced_info_ = serviced_info;
  if (serviced_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ToPolycubed.serviced_info)
}
inline ::commons::ServicedInfo* ToPolycubed::release_serviced_info() {
  
  ::commons::ServicedInfo* temp = serviced_info_;
  serviced_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commons::ServicedInfo* ToPolycubed::unsafe_arena_release_serviced_info() {
  // @@protoc_insertion_point(field_release:commons.ToPolycubed.serviced_info)
  
  ::commons::ServicedInfo* temp = serviced_info_;
  serviced_info_ = nullptr;
  return temp;
}
inline ::commons::ServicedInfo* ToPolycubed::_internal_mutable_serviced_info() {
  
  if (serviced_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::commons::ServicedInfo>(GetArenaForAllocation());
    serviced_info_ = p;
  }
  return serviced_info_;
}
inline ::commons::ServicedInfo* ToPolycubed::mutable_serviced_info() {
  ::commons::ServicedInfo* _msg = _internal_mutable_serviced_info();
  // @@protoc_insertion_point(field_mutable:commons.ToPolycubed.serviced_info)
  return _msg;
}
inline void ToPolycubed::set_allocated_serviced_info(::commons::ServicedInfo* serviced_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete serviced_info_;
  }
  if (serviced_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::commons::ServicedInfo>::GetOwningArena(serviced_info);
    if (message_arena != submessage_arena) {
      serviced_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serviced_info, submessage_arena);
    }
    
  } else {
    
  }
  serviced_info_ = serviced_info;
  // @@protoc_insertion_point(field_set_allocated:commons.ToPolycubed.serviced_info)
}

// bool subscribe = 2;
inline bool ToPolycubed::_internal_has_subscribe() const {
  return to_polycubed_case() == kSubscribe;
}
inline bool ToPolycubed::has_subscribe() const {
  return _internal_has_subscribe();
}
inline void ToPolycubed::set_has_subscribe() {
  _oneof_case_[0] = kSubscribe;
}
inline void ToPolycubed::clear_subscribe() {
  if (_internal_has_subscribe()) {
    to_polycubed_.subscribe_ = false;
    clear_has_to_polycubed();
  }
}
inline bool ToPolycubed::_internal_subscribe() const {
  if (_internal_has_subscribe()) {
    return to_polycubed_.subscribe_;
  }
  return false;
}
inline void ToPolycubed::_internal_set_subscribe(bool value) {
  if (!_internal_has_subscribe()) {
    clear_to_polycubed();
    set_has_subscribe();
  }
  to_polycubed_.subscribe_ = value;
}
inline bool ToPolycubed::subscribe() const {
  // @@protoc_insertion_point(field_get:commons.ToPolycubed.subscribe)
  return _internal_subscribe();
}
inline void ToPolycubed::set_subscribe(bool value) {
  _internal_set_subscribe(value);
  // @@protoc_insertion_point(field_set:commons.ToPolycubed.subscribe)
}

// .commons.ServicedToDataplaneReply serviced_to_dataplane_reply = 3;
inline bool ToPolycubed::_internal_has_serviced_to_dataplane_reply() const {
  return to_polycubed_case() == kServicedToDataplaneReply;
}
inline bool ToPolycubed::has_serviced_to_dataplane_reply() const {
  return _internal_has_serviced_to_dataplane_reply();
}
inline void ToPolycubed::set_has_serviced_to_dataplane_reply() {
  _oneof_case_[0] = kServicedToDataplaneReply;
}
inline void ToPolycubed::clear_serviced_to_dataplane_reply() {
  if (_internal_has_serviced_to_dataplane_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete to_polycubed_.serviced_to_dataplane_reply_;
    }
    clear_has_to_polycubed();
  }
}
inline ::commons::ServicedToDataplaneReply* ToPolycubed::release_serviced_to_dataplane_reply() {
  // @@protoc_insertion_point(field_release:commons.ToPolycubed.serviced_to_dataplane_reply)
  if (_internal_has_serviced_to_dataplane_reply()) {
    clear_has_to_polycubed();
      ::commons::ServicedToDataplaneReply* temp = to_polycubed_.serviced_to_dataplane_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    to_polycubed_.serviced_to_dataplane_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::ServicedToDataplaneReply& ToPolycubed::_internal_serviced_to_dataplane_reply() const {
  return _internal_has_serviced_to_dataplane_reply()
      ? *to_polycubed_.serviced_to_dataplane_reply_
      : reinterpret_cast< ::commons::ServicedToDataplaneReply&>(::commons::_ServicedToDataplaneReply_default_instance_);
}
inline const ::commons::ServicedToDataplaneReply& ToPolycubed::serviced_to_dataplane_reply() const {
  // @@protoc_insertion_point(field_get:commons.ToPolycubed.serviced_to_dataplane_reply)
  return _internal_serviced_to_dataplane_reply();
}
inline ::commons::ServicedToDataplaneReply* ToPolycubed::unsafe_arena_release_serviced_to_dataplane_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ToPolycubed.serviced_to_dataplane_reply)
  if (_internal_has_serviced_to_dataplane_reply()) {
    clear_has_to_polycubed();
    ::commons::ServicedToDataplaneReply* temp = to_polycubed_.serviced_to_dataplane_reply_;
    to_polycubed_.serviced_to_dataplane_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToPolycubed::unsafe_arena_set_allocated_serviced_to_dataplane_reply(::commons::ServicedToDataplaneReply* serviced_to_dataplane_reply) {
  clear_to_polycubed();
  if (serviced_to_dataplane_reply) {
    set_has_serviced_to_dataplane_reply();
    to_polycubed_.serviced_to_dataplane_reply_ = serviced_to_dataplane_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ToPolycubed.serviced_to_dataplane_reply)
}
inline ::commons::ServicedToDataplaneReply* ToPolycubed::_internal_mutable_serviced_to_dataplane_reply() {
  if (!_internal_has_serviced_to_dataplane_reply()) {
    clear_to_polycubed();
    set_has_serviced_to_dataplane_reply();
    to_polycubed_.serviced_to_dataplane_reply_ = CreateMaybeMessage< ::commons::ServicedToDataplaneReply >(GetArenaForAllocation());
  }
  return to_polycubed_.serviced_to_dataplane_reply_;
}
inline ::commons::ServicedToDataplaneReply* ToPolycubed::mutable_serviced_to_dataplane_reply() {
  ::commons::ServicedToDataplaneReply* _msg = _internal_mutable_serviced_to_dataplane_reply();
  // @@protoc_insertion_point(field_mutable:commons.ToPolycubed.serviced_to_dataplane_reply)
  return _msg;
}

// .commons.ServicedToRestUserReply serviced_to_rest_user_reply = 4;
inline bool ToPolycubed::_internal_has_serviced_to_rest_user_reply() const {
  return to_polycubed_case() == kServicedToRestUserReply;
}
inline bool ToPolycubed::has_serviced_to_rest_user_reply() const {
  return _internal_has_serviced_to_rest_user_reply();
}
inline void ToPolycubed::set_has_serviced_to_rest_user_reply() {
  _oneof_case_[0] = kServicedToRestUserReply;
}
inline void ToPolycubed::clear_serviced_to_rest_user_reply() {
  if (_internal_has_serviced_to_rest_user_reply()) {
    if (GetArenaForAllocation() == nullptr) {
      delete to_polycubed_.serviced_to_rest_user_reply_;
    }
    clear_has_to_polycubed();
  }
}
inline ::commons::ServicedToRestUserReply* ToPolycubed::release_serviced_to_rest_user_reply() {
  // @@protoc_insertion_point(field_release:commons.ToPolycubed.serviced_to_rest_user_reply)
  if (_internal_has_serviced_to_rest_user_reply()) {
    clear_has_to_polycubed();
      ::commons::ServicedToRestUserReply* temp = to_polycubed_.serviced_to_rest_user_reply_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    to_polycubed_.serviced_to_rest_user_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::ServicedToRestUserReply& ToPolycubed::_internal_serviced_to_rest_user_reply() const {
  return _internal_has_serviced_to_rest_user_reply()
      ? *to_polycubed_.serviced_to_rest_user_reply_
      : reinterpret_cast< ::commons::ServicedToRestUserReply&>(::commons::_ServicedToRestUserReply_default_instance_);
}
inline const ::commons::ServicedToRestUserReply& ToPolycubed::serviced_to_rest_user_reply() const {
  // @@protoc_insertion_point(field_get:commons.ToPolycubed.serviced_to_rest_user_reply)
  return _internal_serviced_to_rest_user_reply();
}
inline ::commons::ServicedToRestUserReply* ToPolycubed::unsafe_arena_release_serviced_to_rest_user_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ToPolycubed.serviced_to_rest_user_reply)
  if (_internal_has_serviced_to_rest_user_reply()) {
    clear_has_to_polycubed();
    ::commons::ServicedToRestUserReply* temp = to_polycubed_.serviced_to_rest_user_reply_;
    to_polycubed_.serviced_to_rest_user_reply_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ToPolycubed::unsafe_arena_set_allocated_serviced_to_rest_user_reply(::commons::ServicedToRestUserReply* serviced_to_rest_user_reply) {
  clear_to_polycubed();
  if (serviced_to_rest_user_reply) {
    set_has_serviced_to_rest_user_reply();
    to_polycubed_.serviced_to_rest_user_reply_ = serviced_to_rest_user_reply;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ToPolycubed.serviced_to_rest_user_reply)
}
inline ::commons::ServicedToRestUserReply* ToPolycubed::_internal_mutable_serviced_to_rest_user_reply() {
  if (!_internal_has_serviced_to_rest_user_reply()) {
    clear_to_polycubed();
    set_has_serviced_to_rest_user_reply();
    to_polycubed_.serviced_to_rest_user_reply_ = CreateMaybeMessage< ::commons::ServicedToRestUserReply >(GetArenaForAllocation());
  }
  return to_polycubed_.serviced_to_rest_user_reply_;
}
inline ::commons::ServicedToRestUserReply* ToPolycubed::mutable_serviced_to_rest_user_reply() {
  ::commons::ServicedToRestUserReply* _msg = _internal_mutable_serviced_to_rest_user_reply();
  // @@protoc_insertion_point(field_mutable:commons.ToPolycubed.serviced_to_rest_user_reply)
  return _msg;
}

inline bool ToPolycubed::has_to_polycubed() const {
  return to_polycubed_case() != TO_POLYCUBED_NOT_SET;
}
inline void ToPolycubed::clear_has_to_polycubed() {
  _oneof_case_[0] = TO_POLYCUBED_NOT_SET;
}
inline ToPolycubed::ToPolycubedCase ToPolycubed::to_polycubed_case() const {
  return ToPolycubed::ToPolycubedCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServicedToDataplaneReply

// bool success = 1;
inline void ServicedToDataplaneReply::clear_success() {
  success_ = false;
}
inline bool ServicedToDataplaneReply::_internal_success() const {
  return success_;
}
inline bool ServicedToDataplaneReply::success() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneReply.success)
  return _internal_success();
}
inline void ServicedToDataplaneReply::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ServicedToDataplaneReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:commons.ServicedToDataplaneReply.success)
}

// optional string message = 2;
inline bool ServicedToDataplaneReply::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServicedToDataplaneReply::has_message() const {
  return _internal_has_message();
}
inline void ServicedToDataplaneReply::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServicedToDataplaneReply::message() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServicedToDataplaneReply::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.ServicedToDataplaneReply.message)
}
inline std::string* ServicedToDataplaneReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToDataplaneReply.message)
  return _s;
}
inline const std::string& ServicedToDataplaneReply::_internal_message() const {
  return message_.Get();
}
inline void ServicedToDataplaneReply::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServicedToDataplaneReply::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServicedToDataplaneReply::release_message() {
  // @@protoc_insertion_point(field_release:commons.ServicedToDataplaneReply.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServicedToDataplaneReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedToDataplaneReply.message)
}

// -------------------------------------------------------------------

// ServicedToRestUserReply

// bool success = 1;
inline void ServicedToRestUserReply::clear_success() {
  success_ = false;
}
inline bool ServicedToRestUserReply::_internal_success() const {
  return success_;
}
inline bool ServicedToRestUserReply::success() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToRestUserReply.success)
  return _internal_success();
}
inline void ServicedToRestUserReply::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ServicedToRestUserReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:commons.ServicedToRestUserReply.success)
}

// optional string message = 2;
inline bool ServicedToRestUserReply::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServicedToRestUserReply::has_message() const {
  return _internal_has_message();
}
inline void ServicedToRestUserReply::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServicedToRestUserReply::message() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToRestUserReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServicedToRestUserReply::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.ServicedToRestUserReply.message)
}
inline std::string* ServicedToRestUserReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToRestUserReply.message)
  return _s;
}
inline const std::string& ServicedToRestUserReply::_internal_message() const {
  return message_.Get();
}
inline void ServicedToRestUserReply::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServicedToRestUserReply::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServicedToRestUserReply::release_message() {
  // @@protoc_insertion_point(field_release:commons.ServicedToRestUserReply.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServicedToRestUserReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedToRestUserReply.message)
}

// -------------------------------------------------------------------

// ServicedToDataplaneRequest

// .commons.ServicedInfo serviced_info = 1;
inline bool ServicedToDataplaneRequest::_internal_has_serviced_info() const {
  return this != internal_default_instance() && serviced_info_ != nullptr;
}
inline bool ServicedToDataplaneRequest::has_serviced_info() const {
  return _internal_has_serviced_info();
}
inline void ServicedToDataplaneRequest::clear_serviced_info() {
  if (GetArenaForAllocation() == nullptr && serviced_info_ != nullptr) {
    delete serviced_info_;
  }
  serviced_info_ = nullptr;
}
inline const ::commons::ServicedInfo& ServicedToDataplaneRequest::_internal_serviced_info() const {
  const ::commons::ServicedInfo* p = serviced_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::commons::ServicedInfo&>(
      ::commons::_ServicedInfo_default_instance_);
}
inline const ::commons::ServicedInfo& ServicedToDataplaneRequest::serviced_info() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneRequest.serviced_info)
  return _internal_serviced_info();
}
inline void ServicedToDataplaneRequest::unsafe_arena_set_allocated_serviced_info(
    ::commons::ServicedInfo* serviced_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(serviced_info_);
  }
  serviced_info_ = serviced_info;
  if (serviced_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ServicedToDataplaneRequest.serviced_info)
}
inline ::commons::ServicedInfo* ServicedToDataplaneRequest::release_serviced_info() {
  
  ::commons::ServicedInfo* temp = serviced_info_;
  serviced_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commons::ServicedInfo* ServicedToDataplaneRequest::unsafe_arena_release_serviced_info() {
  // @@protoc_insertion_point(field_release:commons.ServicedToDataplaneRequest.serviced_info)
  
  ::commons::ServicedInfo* temp = serviced_info_;
  serviced_info_ = nullptr;
  return temp;
}
inline ::commons::ServicedInfo* ServicedToDataplaneRequest::_internal_mutable_serviced_info() {
  
  if (serviced_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::commons::ServicedInfo>(GetArenaForAllocation());
    serviced_info_ = p;
  }
  return serviced_info_;
}
inline ::commons::ServicedInfo* ServicedToDataplaneRequest::mutable_serviced_info() {
  ::commons::ServicedInfo* _msg = _internal_mutable_serviced_info();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToDataplaneRequest.serviced_info)
  return _msg;
}
inline void ServicedToDataplaneRequest::set_allocated_serviced_info(::commons::ServicedInfo* serviced_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete serviced_info_;
  }
  if (serviced_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::commons::ServicedInfo>::GetOwningArena(serviced_info);
    if (message_arena != submessage_arena) {
      serviced_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, serviced_info, submessage_arena);
    }
    
  } else {
    
  }
  serviced_info_ = serviced_info;
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedToDataplaneRequest.serviced_info)
}

// .commons.CubeInfo cube_info = 2;
inline bool ServicedToDataplaneRequest::_internal_has_cube_info() const {
  return this != internal_default_instance() && cube_info_ != nullptr;
}
inline bool ServicedToDataplaneRequest::has_cube_info() const {
  return _internal_has_cube_info();
}
inline void ServicedToDataplaneRequest::clear_cube_info() {
  if (GetArenaForAllocation() == nullptr && cube_info_ != nullptr) {
    delete cube_info_;
  }
  cube_info_ = nullptr;
}
inline const ::commons::CubeInfo& ServicedToDataplaneRequest::_internal_cube_info() const {
  const ::commons::CubeInfo* p = cube_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::commons::CubeInfo&>(
      ::commons::_CubeInfo_default_instance_);
}
inline const ::commons::CubeInfo& ServicedToDataplaneRequest::cube_info() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneRequest.cube_info)
  return _internal_cube_info();
}
inline void ServicedToDataplaneRequest::unsafe_arena_set_allocated_cube_info(
    ::commons::CubeInfo* cube_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cube_info_);
  }
  cube_info_ = cube_info;
  if (cube_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ServicedToDataplaneRequest.cube_info)
}
inline ::commons::CubeInfo* ServicedToDataplaneRequest::release_cube_info() {
  
  ::commons::CubeInfo* temp = cube_info_;
  cube_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::commons::CubeInfo* ServicedToDataplaneRequest::unsafe_arena_release_cube_info() {
  // @@protoc_insertion_point(field_release:commons.ServicedToDataplaneRequest.cube_info)
  
  ::commons::CubeInfo* temp = cube_info_;
  cube_info_ = nullptr;
  return temp;
}
inline ::commons::CubeInfo* ServicedToDataplaneRequest::_internal_mutable_cube_info() {
  
  if (cube_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::commons::CubeInfo>(GetArenaForAllocation());
    cube_info_ = p;
  }
  return cube_info_;
}
inline ::commons::CubeInfo* ServicedToDataplaneRequest::mutable_cube_info() {
  ::commons::CubeInfo* _msg = _internal_mutable_cube_info();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToDataplaneRequest.cube_info)
  return _msg;
}
inline void ServicedToDataplaneRequest::set_allocated_cube_info(::commons::CubeInfo* cube_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cube_info_;
  }
  if (cube_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::commons::CubeInfo>::GetOwningArena(cube_info);
    if (message_arena != submessage_arena) {
      cube_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cube_info, submessage_arena);
    }
    
  } else {
    
  }
  cube_info_ = cube_info;
  // @@protoc_insertion_point(field_set_allocated:commons.ServicedToDataplaneRequest.cube_info)
}

// .commons.SetRequest set_request = 3;
inline bool ServicedToDataplaneRequest::_internal_has_set_request() const {
  return request_type_case() == kSetRequest;
}
inline bool ServicedToDataplaneRequest::has_set_request() const {
  return _internal_has_set_request();
}
inline void ServicedToDataplaneRequest::set_has_set_request() {
  _oneof_case_[0] = kSetRequest;
}
inline void ServicedToDataplaneRequest::clear_set_request() {
  if (_internal_has_set_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.set_request_;
    }
    clear_has_request_type();
  }
}
inline ::commons::SetRequest* ServicedToDataplaneRequest::release_set_request() {
  // @@protoc_insertion_point(field_release:commons.ServicedToDataplaneRequest.set_request)
  if (_internal_has_set_request()) {
    clear_has_request_type();
      ::commons::SetRequest* temp = request_type_.set_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.set_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::SetRequest& ServicedToDataplaneRequest::_internal_set_request() const {
  return _internal_has_set_request()
      ? *request_type_.set_request_
      : reinterpret_cast< ::commons::SetRequest&>(::commons::_SetRequest_default_instance_);
}
inline const ::commons::SetRequest& ServicedToDataplaneRequest::set_request() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneRequest.set_request)
  return _internal_set_request();
}
inline ::commons::SetRequest* ServicedToDataplaneRequest::unsafe_arena_release_set_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ServicedToDataplaneRequest.set_request)
  if (_internal_has_set_request()) {
    clear_has_request_type();
    ::commons::SetRequest* temp = request_type_.set_request_;
    request_type_.set_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServicedToDataplaneRequest::unsafe_arena_set_allocated_set_request(::commons::SetRequest* set_request) {
  clear_request_type();
  if (set_request) {
    set_has_set_request();
    request_type_.set_request_ = set_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ServicedToDataplaneRequest.set_request)
}
inline ::commons::SetRequest* ServicedToDataplaneRequest::_internal_mutable_set_request() {
  if (!_internal_has_set_request()) {
    clear_request_type();
    set_has_set_request();
    request_type_.set_request_ = CreateMaybeMessage< ::commons::SetRequest >(GetArenaForAllocation());
  }
  return request_type_.set_request_;
}
inline ::commons::SetRequest* ServicedToDataplaneRequest::mutable_set_request() {
  ::commons::SetRequest* _msg = _internal_mutable_set_request();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToDataplaneRequest.set_request)
  return _msg;
}

// .commons.GetRequest get_request = 4;
inline bool ServicedToDataplaneRequest::_internal_has_get_request() const {
  return request_type_case() == kGetRequest;
}
inline bool ServicedToDataplaneRequest::has_get_request() const {
  return _internal_has_get_request();
}
inline void ServicedToDataplaneRequest::set_has_get_request() {
  _oneof_case_[0] = kGetRequest;
}
inline void ServicedToDataplaneRequest::clear_get_request() {
  if (_internal_has_get_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.get_request_;
    }
    clear_has_request_type();
  }
}
inline ::commons::GetRequest* ServicedToDataplaneRequest::release_get_request() {
  // @@protoc_insertion_point(field_release:commons.ServicedToDataplaneRequest.get_request)
  if (_internal_has_get_request()) {
    clear_has_request_type();
      ::commons::GetRequest* temp = request_type_.get_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.get_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::GetRequest& ServicedToDataplaneRequest::_internal_get_request() const {
  return _internal_has_get_request()
      ? *request_type_.get_request_
      : reinterpret_cast< ::commons::GetRequest&>(::commons::_GetRequest_default_instance_);
}
inline const ::commons::GetRequest& ServicedToDataplaneRequest::get_request() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneRequest.get_request)
  return _internal_get_request();
}
inline ::commons::GetRequest* ServicedToDataplaneRequest::unsafe_arena_release_get_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ServicedToDataplaneRequest.get_request)
  if (_internal_has_get_request()) {
    clear_has_request_type();
    ::commons::GetRequest* temp = request_type_.get_request_;
    request_type_.get_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServicedToDataplaneRequest::unsafe_arena_set_allocated_get_request(::commons::GetRequest* get_request) {
  clear_request_type();
  if (get_request) {
    set_has_get_request();
    request_type_.get_request_ = get_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ServicedToDataplaneRequest.get_request)
}
inline ::commons::GetRequest* ServicedToDataplaneRequest::_internal_mutable_get_request() {
  if (!_internal_has_get_request()) {
    clear_request_type();
    set_has_get_request();
    request_type_.get_request_ = CreateMaybeMessage< ::commons::GetRequest >(GetArenaForAllocation());
  }
  return request_type_.get_request_;
}
inline ::commons::GetRequest* ServicedToDataplaneRequest::mutable_get_request() {
  ::commons::GetRequest* _msg = _internal_mutable_get_request();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToDataplaneRequest.get_request)
  return _msg;
}

// .commons.RemoveRequest remove_request = 5;
inline bool ServicedToDataplaneRequest::_internal_has_remove_request() const {
  return request_type_case() == kRemoveRequest;
}
inline bool ServicedToDataplaneRequest::has_remove_request() const {
  return _internal_has_remove_request();
}
inline void ServicedToDataplaneRequest::set_has_remove_request() {
  _oneof_case_[0] = kRemoveRequest;
}
inline void ServicedToDataplaneRequest::clear_remove_request() {
  if (_internal_has_remove_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.remove_request_;
    }
    clear_has_request_type();
  }
}
inline ::commons::RemoveRequest* ServicedToDataplaneRequest::release_remove_request() {
  // @@protoc_insertion_point(field_release:commons.ServicedToDataplaneRequest.remove_request)
  if (_internal_has_remove_request()) {
    clear_has_request_type();
      ::commons::RemoveRequest* temp = request_type_.remove_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.remove_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::RemoveRequest& ServicedToDataplaneRequest::_internal_remove_request() const {
  return _internal_has_remove_request()
      ? *request_type_.remove_request_
      : reinterpret_cast< ::commons::RemoveRequest&>(::commons::_RemoveRequest_default_instance_);
}
inline const ::commons::RemoveRequest& ServicedToDataplaneRequest::remove_request() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneRequest.remove_request)
  return _internal_remove_request();
}
inline ::commons::RemoveRequest* ServicedToDataplaneRequest::unsafe_arena_release_remove_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ServicedToDataplaneRequest.remove_request)
  if (_internal_has_remove_request()) {
    clear_has_request_type();
    ::commons::RemoveRequest* temp = request_type_.remove_request_;
    request_type_.remove_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServicedToDataplaneRequest::unsafe_arena_set_allocated_remove_request(::commons::RemoveRequest* remove_request) {
  clear_request_type();
  if (remove_request) {
    set_has_remove_request();
    request_type_.remove_request_ = remove_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ServicedToDataplaneRequest.remove_request)
}
inline ::commons::RemoveRequest* ServicedToDataplaneRequest::_internal_mutable_remove_request() {
  if (!_internal_has_remove_request()) {
    clear_request_type();
    set_has_remove_request();
    request_type_.remove_request_ = CreateMaybeMessage< ::commons::RemoveRequest >(GetArenaForAllocation());
  }
  return request_type_.remove_request_;
}
inline ::commons::RemoveRequest* ServicedToDataplaneRequest::mutable_remove_request() {
  ::commons::RemoveRequest* _msg = _internal_mutable_remove_request();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToDataplaneRequest.remove_request)
  return _msg;
}

// .commons.Port port = 6;
inline bool ServicedToDataplaneRequest::_internal_has_port() const {
  return request_type_case() == kPort;
}
inline bool ServicedToDataplaneRequest::has_port() const {
  return _internal_has_port();
}
inline void ServicedToDataplaneRequest::set_has_port() {
  _oneof_case_[0] = kPort;
}
inline void ServicedToDataplaneRequest::clear_port() {
  if (_internal_has_port()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_type_.port_;
    }
    clear_has_request_type();
  }
}
inline ::commons::Port* ServicedToDataplaneRequest::release_port() {
  // @@protoc_insertion_point(field_release:commons.ServicedToDataplaneRequest.port)
  if (_internal_has_port()) {
    clear_has_request_type();
      ::commons::Port* temp = request_type_.port_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_type_.port_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::commons::Port& ServicedToDataplaneRequest::_internal_port() const {
  return _internal_has_port()
      ? *request_type_.port_
      : reinterpret_cast< ::commons::Port&>(::commons::_Port_default_instance_);
}
inline const ::commons::Port& ServicedToDataplaneRequest::port() const {
  // @@protoc_insertion_point(field_get:commons.ServicedToDataplaneRequest.port)
  return _internal_port();
}
inline ::commons::Port* ServicedToDataplaneRequest::unsafe_arena_release_port() {
  // @@protoc_insertion_point(field_unsafe_arena_release:commons.ServicedToDataplaneRequest.port)
  if (_internal_has_port()) {
    clear_has_request_type();
    ::commons::Port* temp = request_type_.port_;
    request_type_.port_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServicedToDataplaneRequest::unsafe_arena_set_allocated_port(::commons::Port* port) {
  clear_request_type();
  if (port) {
    set_has_port();
    request_type_.port_ = port;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commons.ServicedToDataplaneRequest.port)
}
inline ::commons::Port* ServicedToDataplaneRequest::_internal_mutable_port() {
  if (!_internal_has_port()) {
    clear_request_type();
    set_has_port();
    request_type_.port_ = CreateMaybeMessage< ::commons::Port >(GetArenaForAllocation());
  }
  return request_type_.port_;
}
inline ::commons::Port* ServicedToDataplaneRequest::mutable_port() {
  ::commons::Port* _msg = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:commons.ServicedToDataplaneRequest.port)
  return _msg;
}

inline bool ServicedToDataplaneRequest::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void ServicedToDataplaneRequest::clear_has_request_type() {
  _oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline ServicedToDataplaneRequest::RequestTypeCase ServicedToDataplaneRequest::request_type_case() const {
  return ServicedToDataplaneRequest::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CubeInfo

// string cube_name = 1;
inline void CubeInfo::clear_cube_name() {
  cube_name_.ClearToEmpty();
}
inline const std::string& CubeInfo::cube_name() const {
  // @@protoc_insertion_point(field_get:commons.CubeInfo.cube_name)
  return _internal_cube_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeInfo::set_cube_name(ArgT0&& arg0, ArgT... args) {
 
 cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeInfo.cube_name)
}
inline std::string* CubeInfo::mutable_cube_name() {
  std::string* _s = _internal_mutable_cube_name();
  // @@protoc_insertion_point(field_mutable:commons.CubeInfo.cube_name)
  return _s;
}
inline const std::string& CubeInfo::_internal_cube_name() const {
  return cube_name_.Get();
}
inline void CubeInfo::_internal_set_cube_name(const std::string& value) {
  
  cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeInfo::_internal_mutable_cube_name() {
  
  return cube_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeInfo::release_cube_name() {
  // @@protoc_insertion_point(field_release:commons.CubeInfo.cube_name)
  return cube_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CubeInfo::set_allocated_cube_name(std::string* cube_name) {
  if (cube_name != nullptr) {
    
  } else {
    
  }
  cube_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cube_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cube_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cube_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeInfo.cube_name)
}

// string map_name = 2;
inline void CubeInfo::clear_map_name() {
  map_name_.ClearToEmpty();
}
inline const std::string& CubeInfo::map_name() const {
  // @@protoc_insertion_point(field_get:commons.CubeInfo.map_name)
  return _internal_map_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeInfo::set_map_name(ArgT0&& arg0, ArgT... args) {
 
 map_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeInfo.map_name)
}
inline std::string* CubeInfo::mutable_map_name() {
  std::string* _s = _internal_mutable_map_name();
  // @@protoc_insertion_point(field_mutable:commons.CubeInfo.map_name)
  return _s;
}
inline const std::string& CubeInfo::_internal_map_name() const {
  return map_name_.Get();
}
inline void CubeInfo::_internal_set_map_name(const std::string& value) {
  
  map_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeInfo::_internal_mutable_map_name() {
  
  return map_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeInfo::release_map_name() {
  // @@protoc_insertion_point(field_release:commons.CubeInfo.map_name)
  return map_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CubeInfo::set_allocated_map_name(std::string* map_name) {
  if (map_name != nullptr) {
    
  } else {
    
  }
  map_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (map_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    map_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeInfo.map_name)
}

// int32 index = 3;
inline void CubeInfo::clear_index() {
  index_ = 0;
}
inline int32_t CubeInfo::_internal_index() const {
  return index_;
}
inline int32_t CubeInfo::index() const {
  // @@protoc_insertion_point(field_get:commons.CubeInfo.index)
  return _internal_index();
}
inline void CubeInfo::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void CubeInfo::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:commons.CubeInfo.index)
}

// .commons.CubeInfo.ProgramType program_type = 4;
inline void CubeInfo::clear_program_type() {
  program_type_ = 0;
}
inline ::commons::CubeInfo_ProgramType CubeInfo::_internal_program_type() const {
  return static_cast< ::commons::CubeInfo_ProgramType >(program_type_);
}
inline ::commons::CubeInfo_ProgramType CubeInfo::program_type() const {
  // @@protoc_insertion_point(field_get:commons.CubeInfo.program_type)
  return _internal_program_type();
}
inline void CubeInfo::_internal_set_program_type(::commons::CubeInfo_ProgramType value) {
  
  program_type_ = value;
}
inline void CubeInfo::set_program_type(::commons::CubeInfo_ProgramType value) {
  _internal_set_program_type(value);
  // @@protoc_insertion_point(field_set:commons.CubeInfo.program_type)
}

// -------------------------------------------------------------------

// CubeManagement

// string cube_name = 1;
inline void CubeManagement::clear_cube_name() {
  cube_name_.ClearToEmpty();
}
inline const std::string& CubeManagement::cube_name() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.cube_name)
  return _internal_cube_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeManagement::set_cube_name(ArgT0&& arg0, ArgT... args) {
 
 cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeManagement.cube_name)
}
inline std::string* CubeManagement::mutable_cube_name() {
  std::string* _s = _internal_mutable_cube_name();
  // @@protoc_insertion_point(field_mutable:commons.CubeManagement.cube_name)
  return _s;
}
inline const std::string& CubeManagement::_internal_cube_name() const {
  return cube_name_.Get();
}
inline void CubeManagement::_internal_set_cube_name(const std::string& value) {
  
  cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeManagement::_internal_mutable_cube_name() {
  
  return cube_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeManagement::release_cube_name() {
  // @@protoc_insertion_point(field_release:commons.CubeManagement.cube_name)
  return cube_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CubeManagement::set_allocated_cube_name(std::string* cube_name) {
  if (cube_name != nullptr) {
    
  } else {
    
  }
  cube_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cube_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cube_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cube_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeManagement.cube_name)
}

// optional string service_name = 2;
inline bool CubeManagement::_internal_has_service_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CubeManagement::has_service_name() const {
  return _internal_has_service_name();
}
inline void CubeManagement::clear_service_name() {
  service_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CubeManagement::service_name() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.service_name)
  return _internal_service_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeManagement::set_service_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeManagement.service_name)
}
inline std::string* CubeManagement::mutable_service_name() {
  std::string* _s = _internal_mutable_service_name();
  // @@protoc_insertion_point(field_mutable:commons.CubeManagement.service_name)
  return _s;
}
inline const std::string& CubeManagement::_internal_service_name() const {
  return service_name_.Get();
}
inline void CubeManagement::_internal_set_service_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  service_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeManagement::_internal_mutable_service_name() {
  _has_bits_[0] |= 0x00000001u;
  return service_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeManagement::release_service_name() {
  // @@protoc_insertion_point(field_release:commons.CubeManagement.service_name)
  if (!_internal_has_service_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = service_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CubeManagement::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  service_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeManagement.service_name)
}

// optional int32 uuid = 3;
inline bool CubeManagement::_internal_has_uuid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CubeManagement::has_uuid() const {
  return _internal_has_uuid();
}
inline void CubeManagement::clear_uuid() {
  uuid_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t CubeManagement::_internal_uuid() const {
  return uuid_;
}
inline int32_t CubeManagement::uuid() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.uuid)
  return _internal_uuid();
}
inline void CubeManagement::_internal_set_uuid(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  uuid_ = value;
}
inline void CubeManagement::set_uuid(int32_t value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:commons.CubeManagement.uuid)
}

// optional .commons.CubeManagement.ServiceType service_type = 4;
inline bool CubeManagement::_internal_has_service_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CubeManagement::has_service_type() const {
  return _internal_has_service_type();
}
inline void CubeManagement::clear_service_type() {
  service_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::commons::CubeManagement_ServiceType CubeManagement::_internal_service_type() const {
  return static_cast< ::commons::CubeManagement_ServiceType >(service_type_);
}
inline ::commons::CubeManagement_ServiceType CubeManagement::service_type() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.service_type)
  return _internal_service_type();
}
inline void CubeManagement::_internal_set_service_type(::commons::CubeManagement_ServiceType value) {
  _has_bits_[0] |= 0x00000040u;
  service_type_ = value;
}
inline void CubeManagement::set_service_type(::commons::CubeManagement_ServiceType value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:commons.CubeManagement.service_type)
}

// optional string ingress_code = 5;
inline bool CubeManagement::_internal_has_ingress_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CubeManagement::has_ingress_code() const {
  return _internal_has_ingress_code();
}
inline void CubeManagement::clear_ingress_code() {
  ingress_code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CubeManagement::ingress_code() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.ingress_code)
  return _internal_ingress_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeManagement::set_ingress_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 ingress_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeManagement.ingress_code)
}
inline std::string* CubeManagement::mutable_ingress_code() {
  std::string* _s = _internal_mutable_ingress_code();
  // @@protoc_insertion_point(field_mutable:commons.CubeManagement.ingress_code)
  return _s;
}
inline const std::string& CubeManagement::_internal_ingress_code() const {
  return ingress_code_.Get();
}
inline void CubeManagement::_internal_set_ingress_code(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ingress_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeManagement::_internal_mutable_ingress_code() {
  _has_bits_[0] |= 0x00000002u;
  return ingress_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeManagement::release_ingress_code() {
  // @@protoc_insertion_point(field_release:commons.CubeManagement.ingress_code)
  if (!_internal_has_ingress_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = ingress_code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ingress_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ingress_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CubeManagement::set_allocated_ingress_code(std::string* ingress_code) {
  if (ingress_code != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ingress_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ingress_code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ingress_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ingress_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeManagement.ingress_code)
}

// optional string egress_code = 6;
inline bool CubeManagement::_internal_has_egress_code() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CubeManagement::has_egress_code() const {
  return _internal_has_egress_code();
}
inline void CubeManagement::clear_egress_code() {
  egress_code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CubeManagement::egress_code() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.egress_code)
  return _internal_egress_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeManagement::set_egress_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 egress_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeManagement.egress_code)
}
inline std::string* CubeManagement::mutable_egress_code() {
  std::string* _s = _internal_mutable_egress_code();
  // @@protoc_insertion_point(field_mutable:commons.CubeManagement.egress_code)
  return _s;
}
inline const std::string& CubeManagement::_internal_egress_code() const {
  return egress_code_.Get();
}
inline void CubeManagement::_internal_set_egress_code(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  egress_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeManagement::_internal_mutable_egress_code() {
  _has_bits_[0] |= 0x00000004u;
  return egress_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeManagement::release_egress_code() {
  // @@protoc_insertion_point(field_release:commons.CubeManagement.egress_code)
  if (!_internal_has_egress_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = egress_code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (egress_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    egress_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CubeManagement::set_allocated_egress_code(std::string* egress_code) {
  if (egress_code != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  egress_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), egress_code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (egress_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    egress_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeManagement.egress_code)
}

// optional string loglevel = 7;
inline bool CubeManagement::_internal_has_loglevel() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CubeManagement::has_loglevel() const {
  return _internal_has_loglevel();
}
inline void CubeManagement::clear_loglevel() {
  loglevel_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CubeManagement::loglevel() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.loglevel)
  return _internal_loglevel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeManagement::set_loglevel(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 loglevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeManagement.loglevel)
}
inline std::string* CubeManagement::mutable_loglevel() {
  std::string* _s = _internal_mutable_loglevel();
  // @@protoc_insertion_point(field_mutable:commons.CubeManagement.loglevel)
  return _s;
}
inline const std::string& CubeManagement::_internal_loglevel() const {
  return loglevel_.Get();
}
inline void CubeManagement::_internal_set_loglevel(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  loglevel_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeManagement::_internal_mutable_loglevel() {
  _has_bits_[0] |= 0x00000008u;
  return loglevel_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeManagement::release_loglevel() {
  // @@protoc_insertion_point(field_release:commons.CubeManagement.loglevel)
  if (!_internal_has_loglevel()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = loglevel_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loglevel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    loglevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CubeManagement::set_allocated_loglevel(std::string* loglevel) {
  if (loglevel != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  loglevel_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), loglevel,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loglevel_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    loglevel_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeManagement.loglevel)
}

// optional string conf = 8;
inline bool CubeManagement::_internal_has_conf() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CubeManagement::has_conf() const {
  return _internal_has_conf();
}
inline void CubeManagement::clear_conf() {
  conf_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CubeManagement::conf() const {
  // @@protoc_insertion_point(field_get:commons.CubeManagement.conf)
  return _internal_conf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CubeManagement::set_conf(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 conf_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.CubeManagement.conf)
}
inline std::string* CubeManagement::mutable_conf() {
  std::string* _s = _internal_mutable_conf();
  // @@protoc_insertion_point(field_mutable:commons.CubeManagement.conf)
  return _s;
}
inline const std::string& CubeManagement::_internal_conf() const {
  return conf_.Get();
}
inline void CubeManagement::_internal_set_conf(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  conf_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CubeManagement::_internal_mutable_conf() {
  _has_bits_[0] |= 0x00000010u;
  return conf_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CubeManagement::release_conf() {
  // @@protoc_insertion_point(field_release:commons.CubeManagement.conf)
  if (!_internal_has_conf()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = conf_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conf_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    conf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CubeManagement::set_allocated_conf(std::string* conf) {
  if (conf != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  conf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), conf,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (conf_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    conf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.CubeManagement.conf)
}

// -------------------------------------------------------------------

// Port

// string name = 1;
inline void Port::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Port::name() const {
  // @@protoc_insertion_point(field_get:commons.Port.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Port::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.Port.name)
}
inline std::string* Port::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:commons.Port.name)
  return _s;
}
inline const std::string& Port::_internal_name() const {
  return name_.Get();
}
inline void Port::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Port::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Port::release_name() {
  // @@protoc_insertion_point(field_release:commons.Port.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Port::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.Port.name)
}

// optional string peer = 2;
inline bool Port::_internal_has_peer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Port::has_peer() const {
  return _internal_has_peer();
}
inline void Port::clear_peer() {
  peer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Port::peer() const {
  // @@protoc_insertion_point(field_get:commons.Port.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Port::set_peer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.Port.peer)
}
inline std::string* Port::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:commons.Port.peer)
  return _s;
}
inline const std::string& Port::_internal_peer() const {
  return peer_.Get();
}
inline void Port::_internal_set_peer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Port::_internal_mutable_peer() {
  _has_bits_[0] |= 0x00000001u;
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Port::release_peer() {
  // @@protoc_insertion_point(field_release:commons.Port.peer)
  if (!_internal_has_peer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = peer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Port::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.Port.peer)
}

// .commons.Port.PortStatus port_status = 3;
inline void Port::clear_port_status() {
  port_status_ = 0;
}
inline ::commons::Port_PortStatus Port::_internal_port_status() const {
  return static_cast< ::commons::Port_PortStatus >(port_status_);
}
inline ::commons::Port_PortStatus Port::port_status() const {
  // @@protoc_insertion_point(field_get:commons.Port.port_status)
  return _internal_port_status();
}
inline void Port::_internal_set_port_status(::commons::Port_PortStatus value) {
  
  port_status_ = value;
}
inline void Port::set_port_status(::commons::Port_PortStatus value) {
  _internal_set_port_status(value);
  // @@protoc_insertion_point(field_set:commons.Port.port_status)
}

// .commons.Port.PortType port_type = 4;
inline void Port::clear_port_type() {
  port_type_ = 0;
}
inline ::commons::Port_PortType Port::_internal_port_type() const {
  return static_cast< ::commons::Port_PortType >(port_type_);
}
inline ::commons::Port_PortType Port::port_type() const {
  // @@protoc_insertion_point(field_get:commons.Port.port_type)
  return _internal_port_type();
}
inline void Port::_internal_set_port_type(::commons::Port_PortType value) {
  
  port_type_ = value;
}
inline void Port::set_port_type(::commons::Port_PortType value) {
  _internal_set_port_type(value);
  // @@protoc_insertion_point(field_set:commons.Port.port_type)
}

// -------------------------------------------------------------------

// MapValue

// bytes byteValues = 1;
inline void MapValue::clear_bytevalues() {
  bytevalues_.ClearToEmpty();
}
inline const std::string& MapValue::bytevalues() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.byteValues)
  return _internal_bytevalues();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapValue::set_bytevalues(ArgT0&& arg0, ArgT... args) {
 
 bytevalues_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.MapValue.byteValues)
}
inline std::string* MapValue::mutable_bytevalues() {
  std::string* _s = _internal_mutable_bytevalues();
  // @@protoc_insertion_point(field_mutable:commons.MapValue.byteValues)
  return _s;
}
inline const std::string& MapValue::_internal_bytevalues() const {
  return bytevalues_.Get();
}
inline void MapValue::_internal_set_bytevalues(const std::string& value) {
  
  bytevalues_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MapValue::_internal_mutable_bytevalues() {
  
  return bytevalues_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MapValue::release_bytevalues() {
  // @@protoc_insertion_point(field_release:commons.MapValue.byteValues)
  return bytevalues_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MapValue::set_allocated_bytevalues(std::string* bytevalues) {
  if (bytevalues != nullptr) {
    
  } else {
    
  }
  bytevalues_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bytevalues,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bytevalues_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bytevalues_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.MapValue.byteValues)
}

// string name = 2;
inline void MapValue::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MapValue::name() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapValue::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.MapValue.name)
}
inline std::string* MapValue::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:commons.MapValue.name)
  return _s;
}
inline const std::string& MapValue::_internal_name() const {
  return name_.Get();
}
inline void MapValue::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MapValue::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MapValue::release_name() {
  // @@protoc_insertion_point(field_release:commons.MapValue.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MapValue::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.MapValue.name)
}

// int32 type = 3;
inline void MapValue::clear_type() {
  type_ = 0;
}
inline int32_t MapValue::_internal_type() const {
  return type_;
}
inline int32_t MapValue::type() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.type)
  return _internal_type();
}
inline void MapValue::_internal_set_type(int32_t value) {
  
  type_ = value;
}
inline void MapValue::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:commons.MapValue.type)
}

// uint64 key_size = 4;
inline void MapValue::clear_key_size() {
  key_size_ = uint64_t{0u};
}
inline uint64_t MapValue::_internal_key_size() const {
  return key_size_;
}
inline uint64_t MapValue::key_size() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.key_size)
  return _internal_key_size();
}
inline void MapValue::_internal_set_key_size(uint64_t value) {
  
  key_size_ = value;
}
inline void MapValue::set_key_size(uint64_t value) {
  _internal_set_key_size(value);
  // @@protoc_insertion_point(field_set:commons.MapValue.key_size)
}

// uint64 leaf_size = 5;
inline void MapValue::clear_leaf_size() {
  leaf_size_ = uint64_t{0u};
}
inline uint64_t MapValue::_internal_leaf_size() const {
  return leaf_size_;
}
inline uint64_t MapValue::leaf_size() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.leaf_size)
  return _internal_leaf_size();
}
inline void MapValue::_internal_set_leaf_size(uint64_t value) {
  
  leaf_size_ = value;
}
inline void MapValue::set_leaf_size(uint64_t value) {
  _internal_set_leaf_size(value);
  // @@protoc_insertion_point(field_set:commons.MapValue.leaf_size)
}

// uint64 max_entries = 6;
inline void MapValue::clear_max_entries() {
  max_entries_ = uint64_t{0u};
}
inline uint64_t MapValue::_internal_max_entries() const {
  return max_entries_;
}
inline uint64_t MapValue::max_entries() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.max_entries)
  return _internal_max_entries();
}
inline void MapValue::_internal_set_max_entries(uint64_t value) {
  
  max_entries_ = value;
}
inline void MapValue::set_max_entries(uint64_t value) {
  _internal_set_max_entries(value);
  // @@protoc_insertion_point(field_set:commons.MapValue.max_entries)
}

// int32 flags = 7;
inline void MapValue::clear_flags() {
  flags_ = 0;
}
inline int32_t MapValue::_internal_flags() const {
  return flags_;
}
inline int32_t MapValue::flags() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.flags)
  return _internal_flags();
}
inline void MapValue::_internal_set_flags(int32_t value) {
  
  flags_ = value;
}
inline void MapValue::set_flags(int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:commons.MapValue.flags)
}

// string key_desc = 8;
inline void MapValue::clear_key_desc() {
  key_desc_.ClearToEmpty();
}
inline const std::string& MapValue::key_desc() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.key_desc)
  return _internal_key_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapValue::set_key_desc(ArgT0&& arg0, ArgT... args) {
 
 key_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.MapValue.key_desc)
}
inline std::string* MapValue::mutable_key_desc() {
  std::string* _s = _internal_mutable_key_desc();
  // @@protoc_insertion_point(field_mutable:commons.MapValue.key_desc)
  return _s;
}
inline const std::string& MapValue::_internal_key_desc() const {
  return key_desc_.Get();
}
inline void MapValue::_internal_set_key_desc(const std::string& value) {
  
  key_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MapValue::_internal_mutable_key_desc() {
  
  return key_desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MapValue::release_key_desc() {
  // @@protoc_insertion_point(field_release:commons.MapValue.key_desc)
  return key_desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MapValue::set_allocated_key_desc(std::string* key_desc) {
  if (key_desc != nullptr) {
    
  } else {
    
  }
  key_desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.MapValue.key_desc)
}

// string leaf_desc = 9;
inline void MapValue::clear_leaf_desc() {
  leaf_desc_.ClearToEmpty();
}
inline const std::string& MapValue::leaf_desc() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.leaf_desc)
  return _internal_leaf_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MapValue::set_leaf_desc(ArgT0&& arg0, ArgT... args) {
 
 leaf_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.MapValue.leaf_desc)
}
inline std::string* MapValue::mutable_leaf_desc() {
  std::string* _s = _internal_mutable_leaf_desc();
  // @@protoc_insertion_point(field_mutable:commons.MapValue.leaf_desc)
  return _s;
}
inline const std::string& MapValue::_internal_leaf_desc() const {
  return leaf_desc_.Get();
}
inline void MapValue::_internal_set_leaf_desc(const std::string& value) {
  
  leaf_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MapValue::_internal_mutable_leaf_desc() {
  
  return leaf_desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MapValue::release_leaf_desc() {
  // @@protoc_insertion_point(field_release:commons.MapValue.leaf_desc)
  return leaf_desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MapValue::set_allocated_leaf_desc(std::string* leaf_desc) {
  if (leaf_desc != nullptr) {
    
  } else {
    
  }
  leaf_desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leaf_desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (leaf_desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    leaf_desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.MapValue.leaf_desc)
}

// optional int32 counter = 10;
inline bool MapValue::_internal_has_counter() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MapValue::has_counter() const {
  return _internal_has_counter();
}
inline void MapValue::clear_counter() {
  counter_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t MapValue::_internal_counter() const {
  return counter_;
}
inline int32_t MapValue::counter() const {
  // @@protoc_insertion_point(field_get:commons.MapValue.counter)
  return _internal_counter();
}
inline void MapValue::_internal_set_counter(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  counter_ = value;
}
inline void MapValue::set_counter(int32_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:commons.MapValue.counter)
}

// -------------------------------------------------------------------

// SetRequest

// bytes key = 1;
inline void SetRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& SetRequest::key() const {
  // @@protoc_insertion_point(field_get:commons.SetRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.SetRequest.key)
}
inline std::string* SetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:commons.SetRequest.key)
  return _s;
}
inline const std::string& SetRequest::_internal_key() const {
  return key_.Get();
}
inline void SetRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetRequest::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetRequest::release_key() {
  // @@protoc_insertion_point(field_release:commons.SetRequest.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.SetRequest.key)
}

// uint64 key_size = 2;
inline void SetRequest::clear_key_size() {
  key_size_ = uint64_t{0u};
}
inline uint64_t SetRequest::_internal_key_size() const {
  return key_size_;
}
inline uint64_t SetRequest::key_size() const {
  // @@protoc_insertion_point(field_get:commons.SetRequest.key_size)
  return _internal_key_size();
}
inline void SetRequest::_internal_set_key_size(uint64_t value) {
  
  key_size_ = value;
}
inline void SetRequest::set_key_size(uint64_t value) {
  _internal_set_key_size(value);
  // @@protoc_insertion_point(field_set:commons.SetRequest.key_size)
}

// bytes value = 3;
inline void SetRequest::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& SetRequest::value() const {
  // @@protoc_insertion_point(field_get:commons.SetRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.SetRequest.value)
}
inline std::string* SetRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:commons.SetRequest.value)
  return _s;
}
inline const std::string& SetRequest::_internal_value() const {
  return value_.Get();
}
inline void SetRequest::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetRequest::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetRequest::release_value() {
  // @@protoc_insertion_point(field_release:commons.SetRequest.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.SetRequest.value)
}

// uint64 value_size = 4;
inline void SetRequest::clear_value_size() {
  value_size_ = uint64_t{0u};
}
inline uint64_t SetRequest::_internal_value_size() const {
  return value_size_;
}
inline uint64_t SetRequest::value_size() const {
  // @@protoc_insertion_point(field_get:commons.SetRequest.value_size)
  return _internal_value_size();
}
inline void SetRequest::_internal_set_value_size(uint64_t value) {
  
  value_size_ = value;
}
inline void SetRequest::set_value_size(uint64_t value) {
  _internal_set_value_size(value);
  // @@protoc_insertion_point(field_set:commons.SetRequest.value_size)
}

// -------------------------------------------------------------------

// GetRequest

// bool all = 1;
inline void GetRequest::clear_all() {
  all_ = false;
}
inline bool GetRequest::_internal_all() const {
  return all_;
}
inline bool GetRequest::all() const {
  // @@protoc_insertion_point(field_get:commons.GetRequest.all)
  return _internal_all();
}
inline void GetRequest::_internal_set_all(bool value) {
  
  all_ = value;
}
inline void GetRequest::set_all(bool value) {
  _internal_set_all(value);
  // @@protoc_insertion_point(field_set:commons.GetRequest.all)
}

// optional bytes key = 2;
inline bool GetRequest::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetRequest::has_key() const {
  return _internal_has_key();
}
inline void GetRequest::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:commons.GetRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRequest::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.GetRequest.key)
}
inline std::string* GetRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:commons.GetRequest.key)
  return _s;
}
inline const std::string& GetRequest::_internal_key() const {
  return key_.Get();
}
inline void GetRequest::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRequest::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:commons.GetRequest.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.GetRequest.key)
}

// uint64 key_size = 3;
inline void GetRequest::clear_key_size() {
  key_size_ = uint64_t{0u};
}
inline uint64_t GetRequest::_internal_key_size() const {
  return key_size_;
}
inline uint64_t GetRequest::key_size() const {
  // @@protoc_insertion_point(field_get:commons.GetRequest.key_size)
  return _internal_key_size();
}
inline void GetRequest::_internal_set_key_size(uint64_t value) {
  
  key_size_ = value;
}
inline void GetRequest::set_key_size(uint64_t value) {
  _internal_set_key_size(value);
  // @@protoc_insertion_point(field_set:commons.GetRequest.key_size)
}

// uint64 value_size = 4;
inline void GetRequest::clear_value_size() {
  value_size_ = uint64_t{0u};
}
inline uint64_t GetRequest::_internal_value_size() const {
  return value_size_;
}
inline uint64_t GetRequest::value_size() const {
  // @@protoc_insertion_point(field_get:commons.GetRequest.value_size)
  return _internal_value_size();
}
inline void GetRequest::_internal_set_value_size(uint64_t value) {
  
  value_size_ = value;
}
inline void GetRequest::set_value_size(uint64_t value) {
  _internal_set_value_size(value);
  // @@protoc_insertion_point(field_set:commons.GetRequest.value_size)
}

// -------------------------------------------------------------------

// RemoveRequest

// bool all = 1;
inline void RemoveRequest::clear_all() {
  all_ = false;
}
inline bool RemoveRequest::_internal_all() const {
  return all_;
}
inline bool RemoveRequest::all() const {
  // @@protoc_insertion_point(field_get:commons.RemoveRequest.all)
  return _internal_all();
}
inline void RemoveRequest::_internal_set_all(bool value) {
  
  all_ = value;
}
inline void RemoveRequest::set_all(bool value) {
  _internal_set_all(value);
  // @@protoc_insertion_point(field_set:commons.RemoveRequest.all)
}

// bytes key = 2;
inline void RemoveRequest::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& RemoveRequest::key() const {
  // @@protoc_insertion_point(field_get:commons.RemoveRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoveRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.RemoveRequest.key)
}
inline std::string* RemoveRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:commons.RemoveRequest.key)
  return _s;
}
inline const std::string& RemoveRequest::_internal_key() const {
  return key_.Get();
}
inline void RemoveRequest::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoveRequest::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoveRequest::release_key() {
  // @@protoc_insertion_point(field_release:commons.RemoveRequest.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoveRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.RemoveRequest.key)
}

// uint64 key_size = 3;
inline void RemoveRequest::clear_key_size() {
  key_size_ = uint64_t{0u};
}
inline uint64_t RemoveRequest::_internal_key_size() const {
  return key_size_;
}
inline uint64_t RemoveRequest::key_size() const {
  // @@protoc_insertion_point(field_get:commons.RemoveRequest.key_size)
  return _internal_key_size();
}
inline void RemoveRequest::_internal_set_key_size(uint64_t value) {
  
  key_size_ = value;
}
inline void RemoveRequest::set_key_size(uint64_t value) {
  _internal_set_key_size(value);
  // @@protoc_insertion_point(field_set:commons.RemoveRequest.key_size)
}

// -------------------------------------------------------------------

// Index

// int32 index = 1;
inline void Index::clear_index() {
  index_ = 0;
}
inline int32_t Index::_internal_index() const {
  return index_;
}
inline int32_t Index::index() const {
  // @@protoc_insertion_point(field_get:commons.Index.index)
  return _internal_index();
}
inline void Index::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void Index::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:commons.Index.index)
}

// -------------------------------------------------------------------

// Dataplane

// string cube_name = 1;
inline void Dataplane::clear_cube_name() {
  cube_name_.ClearToEmpty();
}
inline const std::string& Dataplane::cube_name() const {
  // @@protoc_insertion_point(field_get:commons.Dataplane.cube_name)
  return _internal_cube_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dataplane::set_cube_name(ArgT0&& arg0, ArgT... args) {
 
 cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.Dataplane.cube_name)
}
inline std::string* Dataplane::mutable_cube_name() {
  std::string* _s = _internal_mutable_cube_name();
  // @@protoc_insertion_point(field_mutable:commons.Dataplane.cube_name)
  return _s;
}
inline const std::string& Dataplane::_internal_cube_name() const {
  return cube_name_.Get();
}
inline void Dataplane::_internal_set_cube_name(const std::string& value) {
  
  cube_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Dataplane::_internal_mutable_cube_name() {
  
  return cube_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Dataplane::release_cube_name() {
  // @@protoc_insertion_point(field_release:commons.Dataplane.cube_name)
  return cube_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Dataplane::set_allocated_cube_name(std::string* cube_name) {
  if (cube_name != nullptr) {
    
  } else {
    
  }
  cube_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cube_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cube_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cube_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.Dataplane.cube_name)
}

// optional string code = 2;
inline bool Dataplane::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Dataplane::has_code() const {
  return _internal_has_code();
}
inline void Dataplane::clear_code() {
  code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Dataplane::code() const {
  // @@protoc_insertion_point(field_get:commons.Dataplane.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dataplane::set_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:commons.Dataplane.code)
}
inline std::string* Dataplane::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:commons.Dataplane.code)
  return _s;
}
inline const std::string& Dataplane::_internal_code() const {
  return code_.Get();
}
inline void Dataplane::_internal_set_code(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Dataplane::_internal_mutable_code() {
  _has_bits_[0] |= 0x00000001u;
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Dataplane::release_code() {
  // @@protoc_insertion_point(field_release:commons.Dataplane.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Dataplane::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:commons.Dataplane.code)
}

// int32 index = 3;
inline void Dataplane::clear_index() {
  index_ = 0;
}
inline int32_t Dataplane::_internal_index() const {
  return index_;
}
inline int32_t Dataplane::index() const {
  // @@protoc_insertion_point(field_get:commons.Dataplane.index)
  return _internal_index();
}
inline void Dataplane::_internal_set_index(int32_t value) {
  
  index_ = value;
}
inline void Dataplane::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:commons.Dataplane.index)
}

// .commons.Dataplane.ProgramType program_type = 4;
inline void Dataplane::clear_program_type() {
  program_type_ = 0;
}
inline ::commons::Dataplane_ProgramType Dataplane::_internal_program_type() const {
  return static_cast< ::commons::Dataplane_ProgramType >(program_type_);
}
inline ::commons::Dataplane_ProgramType Dataplane::program_type() const {
  // @@protoc_insertion_point(field_get:commons.Dataplane.program_type)
  return _internal_program_type();
}
inline void Dataplane::_internal_set_program_type(::commons::Dataplane_ProgramType value) {
  
  program_type_ = value;
}
inline void Dataplane::set_program_type(::commons::Dataplane_ProgramType value) {
  _internal_set_program_type(value);
  // @@protoc_insertion_point(field_set:commons.Dataplane.program_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace commons

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::commons::ServicedInfo_ServiceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commons::ServicedInfo_ServiceType>() {
  return ::commons::ServicedInfo_ServiceType_descriptor();
}
template <> struct is_proto_enum< ::commons::CubeInfo_ProgramType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commons::CubeInfo_ProgramType>() {
  return ::commons::CubeInfo_ProgramType_descriptor();
}
template <> struct is_proto_enum< ::commons::CubeManagement_ServiceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commons::CubeManagement_ServiceType>() {
  return ::commons::CubeManagement_ServiceType_descriptor();
}
template <> struct is_proto_enum< ::commons::Port_PortStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commons::Port_PortStatus>() {
  return ::commons::Port_PortStatus_descriptor();
}
template <> struct is_proto_enum< ::commons::Port_PortType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commons::Port_PortType>() {
  return ::commons::Port_PortType_descriptor();
}
template <> struct is_proto_enum< ::commons::Dataplane_ProgramType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::commons::Dataplane_ProgramType>() {
  return ::commons::Dataplane_ProgramType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_polycube_5fgrpc_5fcommons_2eproto
